import _typeof from '@babel/runtime/helpers/typeof';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _objectDestructuringEmpty from '@babel/runtime/helpers/objectDestructuringEmpty';
import _extends from '@babel/runtime/helpers/extends';
import { useMemo, isValidElement, useState, useRef, useEffect, createElement } from 'react';
import { Cell, ResponsiveContainer, PieChart, Label, Pie } from 'recharts';
import '../utils/index.js';
import { componentId as componentId$1 } from '../CommonChartComponents/tokens.js';
import '../CommonChartComponents/index.js';
import { componentId, LABEL_FONT_STYLES, LABEL_DISTANCE_FROM_CENTER, RADIUS_MAPPING, START_AND_END_ANGLES } from './tokens.js';
import '../../BladeProvider/index.js';
import '../../Box/BaseBox/index.js';
import '../../../utils/metaAttribute/index.js';
import getIn from '../../../utils/lodashButBetter/get.js';
import '../../../utils/makeAnalyticsAttribute/index.js';
import '../../../utils/assignWithoutSideEffects/index.js';
import '../../../utils/isValidAllowedChildren/index.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { assignWithoutSideEffects } from '../../../utils/assignWithoutSideEffects/assignWithoutSideEffects.js';
import useTheme from '../../BladeProvider/useTheme.js';
import { getComponentId } from '../../../utils/isValidAllowedChildren/isValidAllowedChildren.js';
import useChartsColorTheme from '../utils/useColorTheme.js';
import { sanitizeString } from '../utils/sanitizeString/sanitizeString.js';
import { assignDataColorMapping } from '../utils/assignDataColorMapping/assignDataColorMapping.js';
import { CommonChartComponentsContext } from '../CommonChartComponents/CommonChartComponentsContext.js';
import { BaseBox } from '../../Box/BaseBox/BaseBox.web.js';
import { metaAttribute } from '../../../utils/metaAttribute/metaAttribute.web.js';
import { makeAnalyticsAttribute } from '../../../utils/makeAnalyticsAttribute/makeAnalyticsAttribute.js';
import { getHighestColorInRange } from '../utils/getHighestColorInRange.js';

var _excluded = ["children", "content", "testID"],
  _excluded2 = ["cx", "cy", "radius", "dataKey", "nameKey", "children", "data", "colorTheme", "type"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var _Cell = function _Cell(_ref) {
  var rest = _extends({}, (_objectDestructuringEmpty(_ref), _ref));
  return /*#__PURE__*/jsx(Cell, _objectSpread({}, rest));
};
var ChartDonutCell = /*#__PURE__*/assignWithoutSideEffects(_Cell, {
  componentId: componentId.cell
});
var getTranslate = function getTranslate(legendLayout, legendAlignment, legendWidth, legendHeight) {
  if (legendLayout === 'vertical') {
    return "translate(calc(-50% + ".concat(legendAlignment === 'right' ? -legendWidth / 2 : legendWidth / 2, "px) ,  calc(-50%))");
  }
  return "translate(-50%, calc(-50% - ".concat(legendHeight / 2, "px))");
};
var ChartDonutWrapper = function ChartDonutWrapper(_ref2) {
  var children = _ref2.children,
    content = _ref2.content,
    testID = _ref2.testID,
    restProps = _objectWithoutProperties(_ref2, _excluded);
  var _useTheme = useTheme(),
    theme = _useTheme.theme;
  var colorTheme = useMemo(function () {
    if (Array.isArray(children)) {
      var _donutChild$props;
      var donutChild = children.find(function (child) {
        return getComponentId(child) === componentId.chartDonut;
      });
      if (!donutChild || ! /*#__PURE__*/isValidElement(donutChild)) {
        return 'categorical';
      }
      return (donutChild === null || donutChild === void 0 || (_donutChild$props = donutChild.props) === null || _donutChild$props === void 0 ? void 0 : _donutChild$props.colorTheme) || 'categorical';
    }
    return 'categorical';
  }, [children]);
  var themeColors = useChartsColorTheme({
    colorTheme: colorTheme,
    chartName: 'donut'
  });
  var _useState = useState(0),
    _useState2 = _slicedToArray(_useState, 2),
    legendHeight = _useState2[0],
    setLegendHeight = _useState2[1];
  var _useState3 = useState(0),
    _useState4 = _slicedToArray(_useState3, 2),
    legendWidth = _useState4[0],
    setLegendWidth = _useState4[1];
  var chartRef = useRef(null);
  var isValuePresentInContent = content && _typeof(content) === 'object' && 'value' in content;
  var isLabelPresentInContent = content && _typeof(content) === 'object' && 'label' in content;
  useEffect(function () {
    var observer = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
        if (mutation.type === 'childList') {
          var _chartRef$current;
          var legendWrapper = (_chartRef$current = chartRef.current) === null || _chartRef$current === void 0 ? void 0 : _chartRef$current.querySelector('.recharts-legend-wrapper');
          if (legendWrapper) {
            var height = legendWrapper.getBoundingClientRect().height;
            var width = legendWrapper.getBoundingClientRect().width;
            setLegendHeight(height);
            setLegendWidth(width);
          }
        }
      });
    });
    if (chartRef.current) {
      observer.observe(chartRef.current, {
        childList: true,
        subtree: true
      });
    }
    return function () {
      return observer.disconnect();
    };
  }, []);
  var pieChartRadius = useMemo(function () {
    if (Array.isArray(children)) {
      var _donutChild$props2;
      var donutChild = children.find(function (child) {
        return getComponentId(child) === componentId.chartDonut;
      });
      if (!donutChild || ! /*#__PURE__*/isValidElement(donutChild)) {
        return 'medium';
      }
      return (donutChild === null || donutChild === void 0 || (_donutChild$props2 = donutChild.props) === null || _donutChild$props2 === void 0 ? void 0 : _donutChild$props2.radius) || 'medium';
    }
    return 'medium';
  }, [children]);
  var legendLayout = useMemo(function () {
    if (Array.isArray(children)) {
      var _legendChild$props;
      var legendChild = children.find(function (child) {
        return getComponentId(child) === componentId$1.chartLegend;
      });
      if (!legendChild || ! /*#__PURE__*/isValidElement(legendChild)) {
        return 'horizontal';
      }
      return (legendChild === null || legendChild === void 0 || (_legendChild$props = legendChild.props) === null || _legendChild$props === void 0 ? void 0 : _legendChild$props.layout) || 'horizontal';
    }
    return 'horizontal';
  }, [children]);
  var legendAlignment = useMemo(function () {
    if (Array.isArray(children)) {
      var _legendChild$props2;
      var legendChild = children.find(function (child) {
        return getComponentId(child) === componentId$1.chartLegend;
      });
      if (!legendChild || ! /*#__PURE__*/isValidElement(legendChild)) {
        return 'right';
      }
      return (legendChild === null || legendChild === void 0 || (_legendChild$props2 = legendChild.props) === null || _legendChild$props2 === void 0 ? void 0 : _legendChild$props2.align) || 'right';
    }
    return 'right';
  }, [children]);
  /**
   * We need to  check child of ChartDonutWrapper. if they have any custom color we store that.
   * We need these mapping because colors of tooltip & legend is determine based on this
   *  recharts do provide a color but it is hex code and we need blade color token .
   */

  var dataColorMapping = useMemo(function () {
    var dataColorMapping = {};
    if (Array.isArray(children)) {
      children.forEach(function (child) {
        if (getComponentId(child) === componentId.chartDonut) {
          var data = child.props.data;
          // Donut Chart can also have <Cell/>  which will come under donutChildren.
          var donutChildren = child.props.children;
          if (Array.isArray(donutChildren)) {
            donutChildren.forEach(function (child, index) {
              var _data$index;
              if (getComponentId(child) === componentId.cell && (_data$index = data[index]) !== null && _data$index !== void 0 && _data$index.name) {
                var _child$props, _child$props2;
                //  assign  colors to the dataColorMapping, if no color is assigned  we assign color in `assignDataColorMapping`

                dataColorMapping[sanitizeString(data[index].name)] = {
                  colorToken: (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.color,
                  isCustomColor: Boolean((_child$props2 = child.props) === null || _child$props2 === void 0 ? void 0 : _child$props2.color)
                };
              }
            });
          } else {
            // if we don't have cell as child component then we can we directly assign theme colors
            data.forEach(function (item, index) {
              dataColorMapping[sanitizeString(item.name)] = {
                colorToken: themeColors[index],
                isCustomColor: false
              };
            });
          }
        }
      });
    }
    assignDataColorMapping(dataColorMapping, themeColors);
    return dataColorMapping;
  }, [children, themeColors]);
  return /*#__PURE__*/jsx(CommonChartComponentsContext.Provider, {
    value: {
      chartName: 'donut',
      dataColorMapping: dataColorMapping
    },
    children: /*#__PURE__*/jsxs(BaseBox, _objectSpread(_objectSpread(_objectSpread(_objectSpread({
      ref: chartRef
    }, metaAttribute({
      name: 'donut-chart',
      testID: testID
    })), makeAnalyticsAttribute(restProps)), {}, {
      width: "100%",
      height: "100%"
    }, restProps), {}, {
      position: /*#__PURE__*/isValidElement(content) ? 'relative' : undefined,
      children: [/*#__PURE__*/jsx(ResponsiveContainer, {
        width: "100%",
        height: "100%",
        children: /*#__PURE__*/jsxs(PieChart, {
          children: [children, isLabelPresentInContent && /*#__PURE__*/jsx(Label, {
            position: "center",
            fill: theme.colors.surface.text.gray.muted,
            fontSize: theme.typography.fonts.size[LABEL_FONT_STYLES[pieChartRadius].fontSize.label],
            fontFamily: theme.typography.fonts.family.text,
            fontWeight: theme.typography.fonts.weight.medium,
            letterSpacing: theme.typography.letterSpacings[100],
            dy: isValuePresentInContent ? LABEL_DISTANCE_FROM_CENTER[pieChartRadius].withText : LABEL_DISTANCE_FROM_CENTER[pieChartRadius].normal,
            children: content === null || content === void 0 ? void 0 : content.label
          }), isValuePresentInContent && /*#__PURE__*/jsx(Label, {
            position: "center",
            fill: theme.colors.surface.text.gray.normal,
            fontSize: theme.typography.fonts.size[LABEL_FONT_STYLES[pieChartRadius].fontSize.text],
            fontFamily: theme.typography.fonts.family.heading,
            fontWeight: theme.typography.fonts.weight.bold,
            letterSpacing: theme.typography.letterSpacings[100],
            dy: isLabelPresentInContent ? LABEL_DISTANCE_FROM_CENTER[pieChartRadius].withLabel : LABEL_DISTANCE_FROM_CENTER[pieChartRadius].normal,
            children: content === null || content === void 0 ? void 0 : content.value
          })]
        })
      }), /*#__PURE__*/isValidElement(content) && /*#__PURE__*/jsx(BaseBox, {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: getTranslate(legendLayout, legendAlignment, legendWidth, legendHeight),
        zIndex: 10,
        textAlign: "center",
        children: content
      })]
    }))
  });
};
var _ChartDonut = function _ChartDonut(_ref3) {
  var _ref3$cx = _ref3.cx,
    cx = _ref3$cx === void 0 ? '50%' : _ref3$cx,
    _ref3$cy = _ref3.cy,
    cy = _ref3$cy === void 0 ? '50%' : _ref3$cy,
    _ref3$radius = _ref3.radius,
    radius = _ref3$radius === void 0 ? 'medium' : _ref3$radius,
    dataKey = _ref3.dataKey,
    nameKey = _ref3.nameKey,
    children = _ref3.children,
    data = _ref3.data,
    _ref3$colorTheme = _ref3.colorTheme,
    colorTheme = _ref3$colorTheme === void 0 ? 'categorical' : _ref3$colorTheme,
    _ref3$type = _ref3.type,
    type = _ref3$type === void 0 ? 'circle' : _ref3$type,
    rest = _objectWithoutProperties(_ref3, _excluded2);
  var radiusConfig = RADIUS_MAPPING[radius];
  var themeColors = useChartsColorTheme({
    colorTheme: colorTheme,
    chartName: 'donut'
  });
  var _useState5 = useState(null),
    _useState6 = _slicedToArray(_useState5, 2),
    hoveredIndex = _useState6[0],
    setHoveredIndex = _useState6[1];
  var _useTheme2 = useTheme(),
    theme = _useTheme2.theme;
  var getCellOpacity = function getCellOpacity(hoveredIndex, currentIndex) {
    if (hoveredIndex === null) return 1;
    if (hoveredIndex === currentIndex) return 1;
    return 0.2;
  };
  var modifiedChildren = useMemo(function () {
    if (Array.isArray(children)) {
      return children.map(function (child, index) {
        if (getComponentId(child) === componentId.cell) {
          /* 
           Why we are not using React.cloneElement ?  just use ChartDonutCell no?
           cell can never be  custom component in recharts. (as of v3.1.2)
           (https://github.com/recharts/recharts/issues/2788)
           https://github.com/recharts/recharts/discussions/5474
            So we have placeholder component ChartDonutCell. which we replaced by RechartsCell internally so dev can see hover effects
           working out of box. 
           */
          var fill = getIn(theme.colors, child.props.color || themeColors[index]);
          return /*#__PURE__*/createElement(Cell, _objectSpread(_objectSpread({}, child.props), {}, {
            fill: fill,
            key: index,
            opacity: getCellOpacity(hoveredIndex, index),
            strokeWidth: 0
          }));
        } else {
          return child;
        }
      });
    }
    return data === null || data === void 0 ? void 0 : data.map(function (_, index) {
      return /*#__PURE__*/jsx(Cell, {
        fill: getIn(theme.colors, themeColors[index]),
        opacity: getCellOpacity(hoveredIndex, index),
        strokeWidth: 0
      }, index);
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [children, data, colorTheme, hoveredIndex, themeColors]);
  var modifiedExternalDonutChildren = useMemo(function () {
    if (Array.isArray(children)) {
      return children.map(function (child, index) {
        if (getComponentId(child) === componentId.cell) {
          /* 
           Why we are not using React.cloneElement ?  just use ChartDonutCell no?
           cell can never be  custom component in recharts. (as of v3.1.2)
           (https://github.com/recharts/recharts/issues/2788)
           https://github.com/recharts/recharts/discussions/5474
            So we have placeholder component ChartDonutCell. which we replaced by RechartsCell internally so dev can see hover effects
           working out of box. 
           */

          var fill = getIn(theme.colors, getHighestColorInRange({
            colorToken: child.props.color || themeColors[index],
            followIntensityMapping: Boolean(child.props.color)
          }));
          return /*#__PURE__*/createElement(Cell, _objectSpread(_objectSpread({}, child.props), {}, {
            key: "stroke-".concat(index),
            fill: "transparent",
            stroke: fill // Different stroke color for each cell
            ,
            strokeWidth: 0.75,
            strokeOpacity: getCellOpacity(hoveredIndex, index)
          }));
        } else {
          return child;
        }
      });
    }
    return data === null || data === void 0 ? void 0 : data.map(function (_, index) {
      return /*#__PURE__*/jsx(Cell, {
        fill: "transparent",
        stroke: getIn(theme.colors, getHighestColorInRange({
          colorToken: themeColors[index]
        })) // Different stroke color for each cell
        ,
        strokeWidth: 0.75,
        strokeOpacity: getCellOpacity(hoveredIndex, index)
      }, "stroke-".concat(index));
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [children, data, colorTheme, hoveredIndex, themeColors]);
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(Pie, _objectSpread(_objectSpread({}, rest), {}, {
      cx: cx,
      cy: cy,
      outerRadius: radiusConfig.outerRadius,
      innerRadius: radiusConfig.innerRadius,
      data: data,
      startAngle: START_AND_END_ANGLES[type].startAngle,
      endAngle: START_AND_END_ANGLES[type].endAngle,
      onMouseEnter: function onMouseEnter(data, index) {
        setHoveredIndex(index);
      },
      onMouseLeave: function onMouseLeave() {
        setHoveredIndex(null);
      },
      paddingAngle: 1.5,
      children: modifiedChildren
    })), /*#__PURE__*/jsx(Pie, {
      cx: cx,
      cy: cy,
      outerRadius: radiusConfig.outerRadius,
      innerRadius: radiusConfig.outerRadius - 0.75 // 1.5px thick stroke
      ,
      data: data,
      startAngle: START_AND_END_ANGLES[type].startAngle,
      endAngle: START_AND_END_ANGLES[type].endAngle,
      fill: "transparent",
      legendType: "none",
      tooltipType: "none",
      paddingAngle: 1.5,
      children: modifiedExternalDonutChildren
    })]
  });
};
var ChartDonut = /*#__PURE__*/assignWithoutSideEffects(_ChartDonut, {
  componentId: componentId.chartDonut
});

export { ChartDonut, ChartDonutCell, ChartDonutWrapper };
//# sourceMappingURL=DonutChart.web.js.map
