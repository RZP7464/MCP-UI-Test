import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import React__default from 'react';
import { Area as Area$1, ResponsiveContainer, AreaChart } from 'recharts';
import '../utils/index.js';
import '../CommonChartComponents/index.js';
import { componentIds } from './componentIds.js';
import '../../../utils/makeAnalyticsAttribute/index.js';
import '../../BladeProvider/index.js';
import '../../../utils/metaAttribute/index.js';
import '../../Box/BaseBox/index.js';
import getIn from '../../../utils/lodashButBetter/get.js';
import '../../../utils/assignWithoutSideEffects/index.js';
import '../../../utils/isValidAllowedChildren/index.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import useTheme from '../../BladeProvider/useTheme.js';
import useChartsColorTheme from '../utils/useColorTheme.js';
import { getHighestColorInRange } from '../utils/getHighestColorInRange.js';
import { assignWithoutSideEffects } from '../../../utils/assignWithoutSideEffects/assignWithoutSideEffects.js';
import { getComponentId } from '../../../utils/isValidAllowedChildren/isValidAllowedChildren.js';
import { assignDataColorMapping } from '../utils/assignDataColorMapping/assignDataColorMapping.js';
import { CommonChartComponentsContext } from '../CommonChartComponents/CommonChartComponentsContext.js';
import { BaseBox } from '../../Box/BaseBox/BaseBox.web.js';
import { metaAttribute } from '../../../utils/metaAttribute/metaAttribute.web.js';
import { makeAnalyticsAttribute } from '../../../utils/makeAnalyticsAttribute/makeAnalyticsAttribute.js';

var _excluded = ["color", "type", "connectNulls", "showLegend", "stackId", "dot", "activeDot", "_index", "_colorTheme", "_totalAreas", "dataKey", "name"],
  _excluded2 = ["data", "children", "testID", "colorTheme"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var Area = function Area(_ref) {
  var color = _ref.color,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'monotone' : _ref$type,
    _ref$connectNulls = _ref.connectNulls,
    connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls,
    _ref$showLegend = _ref.showLegend,
    showLegend = _ref$showLegend === void 0 ? true : _ref$showLegend,
    _ref$stackId = _ref.stackId,
    stackId = _ref$stackId === void 0 ? 1 : _ref$stackId,
    _ref$dot = _ref.dot,
    dot = _ref$dot === void 0 ? false : _ref$dot,
    _ref$activeDot = _ref.activeDot,
    activeDot = _ref$activeDot === void 0 ? true : _ref$activeDot,
    _index = _ref._index,
    _colorTheme = _ref._colorTheme,
    _totalAreas = _ref._totalAreas,
    dataKey = _ref.dataKey,
    name = _ref.name,
    props = _objectWithoutProperties(_ref, _excluded);
  var _useTheme = useTheme(),
    theme = _useTheme.theme;
  var themeColors = useChartsColorTheme({
    colorTheme: _colorTheme,
    chartName: 'area',
    chartDataIndicators: _totalAreas
  });
  var colorToken = getIn(theme.colors, color ? getHighestColorInRange({
    colorToken: color
  }) : themeColors[_index !== null && _index !== void 0 ? _index : 0]);
  var animationBegin = theme.motion.delay.gentle;
  var animationDuration = theme.motion.duration.xgentle;
  return /*#__PURE__*/jsx(Area$1, _objectSpread(_objectSpread({}, props), {}, {
    fill: "url(#color-".concat(_index, "-").concat(dataKey, ")"),
    dataKey: dataKey,
    name: name,
    stroke: colorToken,
    fillOpacity: 0.5,
    type: type,
    connectNulls: connectNulls,
    legendType: showLegend ? 'rect' : 'none',
    strokeWidth: 1.5,
    dot: dot,
    stackId: stackId,
    activeDot: activeDot,
    animationBegin: animationBegin,
    animationDuration: animationDuration
  }));
};
var ChartArea = /*#__PURE__*/assignWithoutSideEffects(Area, {
  componentId: componentIds.ChartArea
});
var ChartColorGradient = function ChartColorGradient(_ref2) {
  var index = _ref2.index,
    color = _ref2.color,
    totalAreaChartChildren = _ref2.totalAreaChartChildren,
    id = _ref2.id;
  var _useTheme2 = useTheme(),
    colorScheme = _useTheme2.colorScheme,
    theme = _useTheme2.theme;
  var isDarkMode = colorScheme === 'dark';
  var themeColors = useChartsColorTheme({
    colorTheme: 'categorical',
    chartName: 'area',
    chartDataIndicators: totalAreaChartChildren
  });
  var colorToken = getIn(theme.colors, getHighestColorInRange({
    colorToken: color !== null && color !== void 0 ? color : themeColors[index],
    followIntensityMapping: true
  }));
  return /*#__PURE__*/jsxs("linearGradient", {
    id: id,
    x1: "0",
    y1: "0",
    x2: "0",
    y2: "1",
    children: [/*#__PURE__*/jsx("stop", {
      offset: "5%",
      stopColor: colorToken,
      stopOpacity: isDarkMode ? 0.28 : 1
    }), /*#__PURE__*/jsx("stop", {
      offset: "95%",
      stopColor: colorToken,
      stopOpacity: isDarkMode ? 0.12 : 0.32
    })]
  }, id);
};

// Main components
var ChartAreaWrapper = function ChartAreaWrapper(_ref3) {
  var data = _ref3.data,
    children = _ref3.children,
    testID = _ref3.testID,
    _ref3$colorTheme = _ref3.colorTheme,
    colorTheme = _ref3$colorTheme === void 0 ? 'categorical' : _ref3$colorTheme,
    restProps = _objectWithoutProperties(_ref3, _excluded2);
  var themeColors = useChartsColorTheme({
    colorTheme: colorTheme,
    chartName: 'area'
  });
  var _React$useMemo = React__default.useMemo(function () {
      var childrenArray = React__default.Children.toArray(children);
      var dataColorMapping = {};

      // Count ChartLine components
      var totalAreas = childrenArray.filter(function (child) {
        return /*#__PURE__*/React__default.isValidElement(child) && getComponentId(child) === componentIds.ChartArea;
      }).length;
      var AreaChartIndex = 0;
      /**
       * We need to check child of ChartAreaWrapper. if they have any custom color we store that.
       * We need these mapping because colors of tooltip & legend is determine based on this
       *  recharts do provide a color but it is hex code and we need blade color token .
       */
      var modifiedChildren = React__default.Children.map(children, function (child) {
        if (/*#__PURE__*/React__default.isValidElement(child) && getComponentId(child) === componentIds.ChartArea) {
          var _child$props, _child$props2;
          var childColor = child === null || child === void 0 || (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.color;
          var dataKey = child === null || child === void 0 || (_child$props2 = child.props) === null || _child$props2 === void 0 ? void 0 : _child$props2.dataKey;
          if (dataKey) {
            //  assign  colors to the dataColorMapping, if no color is assigned  we assign color in `assignDataColorMapping`

            dataColorMapping[dataKey] = {
              colorToken: childColor,
              isCustomColor: Boolean(childColor)
            };
          }
          return /*#__PURE__*/React__default.cloneElement(child, {
            _index: AreaChartIndex++,
            _colorTheme: colorTheme,
            _totalAreas: totalAreas
          });
        }
        return child;
      });
      assignDataColorMapping(dataColorMapping, themeColors);
      return {
        modifiedChildren: modifiedChildren,
        totalAreaChartChildren: AreaChartIndex,
        dataColorMapping: dataColorMapping
      };
    }, [children, colorTheme, themeColors]),
    modifiedChildren = _React$useMemo.modifiedChildren,
    totalAreaChartChildren = _React$useMemo.totalAreaChartChildren,
    dataColorMapping = _React$useMemo.dataColorMapping;
  return /*#__PURE__*/jsx(CommonChartComponentsContext.Provider, {
    value: {
      chartName: 'area',
      dataColorMapping: dataColorMapping
    },
    children: /*#__PURE__*/jsx(BaseBox, _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, metaAttribute({
      name: 'chart-area-container',
      testID: testID
    })), makeAnalyticsAttribute(restProps)), restProps), {}, {
      width: "100%",
      height: "100%",
      children: /*#__PURE__*/jsx(ResponsiveContainer, {
        children: /*#__PURE__*/jsxs(AreaChart, {
          data: data,
          children: [/*#__PURE__*/jsx("defs", {
            children: Object.keys(dataColorMapping).map(function (dataKey, index) {
              return /*#__PURE__*/jsx(ChartColorGradient, {
                id: "color-".concat(index, "-").concat(dataKey),
                index: index,
                color: dataColorMapping[dataKey].colorToken,
                totalAreaChartChildren: totalAreaChartChildren
              }, "color-".concat(index, "-").concat(dataKey));
            })
          }), modifiedChildren]
        })
      })
    }))
  });
};

export { ChartArea, ChartAreaWrapper };
//# sourceMappingURL=AreaChart.web.js.map
