import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import React__default from 'react';
import { Line as Line$1, ResponsiveContainer, LineChart } from 'recharts';
import '../utils/index.js';
import '../CommonChartComponents/index.js';
import { componentIds } from './componentIds.js';
import '../../../utils/metaAttribute/index.js';
import '../../BladeProvider/index.js';
import '../../Box/BaseBox/index.js';
import getIn from '../../../utils/lodashButBetter/get.js';
import '../../../utils/makeAnalyticsAttribute/index.js';
import '../../../utils/isValidAllowedChildren/index.js';
import '../../../utils/assignWithoutSideEffects/index.js';
import { jsx } from 'react/jsx-runtime';
import useTheme from '../../BladeProvider/useTheme.js';
import useChartsColorTheme from '../utils/useColorTheme.js';
import { assignWithoutSideEffects } from '../../../utils/assignWithoutSideEffects/assignWithoutSideEffects.js';
import { getComponentId } from '../../../utils/isValidAllowedChildren/isValidAllowedChildren.js';
import { assignDataColorMapping } from '../utils/assignDataColorMapping/assignDataColorMapping.js';
import { CommonChartComponentsContext } from '../CommonChartComponents/CommonChartComponentsContext.js';
import { BaseBox } from '../../Box/BaseBox/BaseBox.web.js';
import { metaAttribute } from '../../../utils/metaAttribute/metaAttribute.web.js';
import { makeAnalyticsAttribute } from '../../../utils/makeAnalyticsAttribute/makeAnalyticsAttribute.js';

var _excluded = ["color", "strokeStyle", "type", "dot", "activeDot", "showLegend", "_index", "_colorTheme", "_totalLines"],
  _excluded2 = ["children", "colorTheme", "testID", "data"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var Line = function Line(_ref) {
  var color = _ref.color,
    _ref$strokeStyle = _ref.strokeStyle,
    strokeStyle = _ref$strokeStyle === void 0 ? 'solid' : _ref$strokeStyle,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'monotone' : _ref$type,
    _ref$dot = _ref.dot,
    dot = _ref$dot === void 0 ? false : _ref$dot,
    _ref$activeDot = _ref.activeDot,
    activeDot = _ref$activeDot === void 0 ? true : _ref$activeDot,
    _ref$showLegend = _ref.showLegend,
    showLegend = _ref$showLegend === void 0 ? true : _ref$showLegend,
    _index = _ref._index,
    _colorTheme = _ref._colorTheme,
    _totalLines = _ref._totalLines,
    props = _objectWithoutProperties(_ref, _excluded);
  var _useTheme = useTheme(),
    theme = _useTheme.theme;
  var themeColors = useChartsColorTheme({
    colorTheme: _colorTheme,
    chartName: 'line',
    chartDataIndicators: _totalLines
  });
  var colorToken = getIn(theme.colors, color !== null && color !== void 0 ? color : themeColors[_index !== null && _index !== void 0 ? _index : 0]);
  var strokeDasharray = strokeStyle === 'dashed' ? '5 5' : strokeStyle === 'dotted' ? '2 2' : undefined;
  var isLineDotted = strokeStyle === 'dashed';
  var animationBegin = isLineDotted ? theme.motion.delay.gentle + theme.motion.duration.xgentle : theme.motion.delay.gentle;
  var animationDuration = theme.motion.duration.xgentle;
  return /*#__PURE__*/jsx(Line$1, _objectSpread({
    stroke: colorToken,
    strokeWidth: 1.5,
    strokeDasharray: strokeDasharray,
    type: type,
    activeDot: activeDot,
    dot: dot,
    legendType: showLegend ? 'line' : 'none',
    animationBegin: animationBegin,
    animationDuration: animationDuration,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }, props));
};
var ChartLine = /*#__PURE__*/assignWithoutSideEffects(Line, {
  componentId: componentIds.ChartLine
});

// Main components
var ChartLineWrapper = function ChartLineWrapper(_ref2) {
  var children = _ref2.children,
    _ref2$colorTheme = _ref2.colorTheme,
    colorTheme = _ref2$colorTheme === void 0 ? 'categorical' : _ref2$colorTheme,
    testID = _ref2.testID,
    data = _ref2.data,
    restProps = _objectWithoutProperties(_ref2, _excluded2);
  var themeColors = useChartsColorTheme({
    colorTheme: colorTheme,
    chartName: 'line'
  });
  /**
   * We need to check child of CharLineWrapper. if they have any custom color we store that.
   * We need these mapping because colors of tooltip & legend is determine based on this
   *  recharts do provide a color but it is hex code and we need blade color token .
   */

  var _React$useMemo = React__default.useMemo(function () {
      var childrenArray = React__default.Children.toArray(children);
      var dataColorMapping = {};
      // Count ChartLine components
      var totalLines = childrenArray.filter(function (child) {
        return /*#__PURE__*/React__default.isValidElement(child) && getComponentId(child) === componentIds.ChartLine;
      }).length;
      var LineChartIndex = 0;
      var lineChartModifiedChildrens = React__default.Children.map(children, function (child) {
        if (/*#__PURE__*/React__default.isValidElement(child) && getComponentId(child) === componentIds.ChartLine) {
          var _child$props, _child$props2;
          var childColor = child === null || child === void 0 || (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.color;
          var dataKey = child === null || child === void 0 || (_child$props2 = child.props) === null || _child$props2 === void 0 ? void 0 : _child$props2.dataKey;
          if (dataKey) {
            /**
             *  if we have custom color given by user we use that other wise we just
             *  assign theme colors to the dataColorMapping, in `assignDataColorMapping`
             */
            dataColorMapping[dataKey] = {
              colorToken: childColor,
              isCustomColor: Boolean(childColor)
            };
          }
          return /*#__PURE__*/React__default.cloneElement(child, {
            _index: LineChartIndex++,
            _colorTheme: colorTheme,
            _totaLine: totalLines
          });
        }
        return child;
      });
      assignDataColorMapping(dataColorMapping, themeColors);
      return {
        dataColorMapping: dataColorMapping,
        lineChartModifiedChildrens: lineChartModifiedChildrens,
        totalLines: totalLines
      };
    }, [children, colorTheme, themeColors]),
    dataColorMapping = _React$useMemo.dataColorMapping,
    lineChartModifiedChildrens = _React$useMemo.lineChartModifiedChildrens;
  return /*#__PURE__*/jsx(CommonChartComponentsContext.Provider, {
    value: {
      chartName: 'line',
      dataColorMapping: dataColorMapping
    },
    children: /*#__PURE__*/jsx(BaseBox, _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, metaAttribute({
      name: 'line-chart',
      testID: testID
    })), makeAnalyticsAttribute(restProps)), {}, {
      width: "100%",
      height: "100%"
    }, restProps), {}, {
      children: /*#__PURE__*/jsx(ResponsiveContainer, {
        width: "100%",
        height: "100%",
        children: /*#__PURE__*/jsx(LineChart, {
          data: data,
          children: lineChartModifiedChildrens
        })
      })
    }))
  });
};

export { ChartLine, ChartLineWrapper };
//# sourceMappingURL=LineChart.web.js.map
