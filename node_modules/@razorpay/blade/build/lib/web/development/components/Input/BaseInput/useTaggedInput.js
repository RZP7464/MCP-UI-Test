import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import React__default from 'react';
import { getTagsGroup } from '../../Tag/getTagsGroup.js';
import '../../../utils/index.js';
import { useControllableState } from '../../../utils/useControllable.js';
import { isReactNative } from '../../../utils/platform/isReactNative.js';

var useTaggedInput = function useTaggedInput(_ref) {
  var tags = _ref.tags,
    isDisabled = _ref.isDisabled,
    onTagChange = _ref.onTagChange,
    isTaggedInput = _ref.isTaggedInput,
    inputRef = _ref.inputRef,
    onChange = _ref.onChange,
    name = _ref.name,
    value = _ref.value,
    defaultValue = _ref.defaultValue;
  var _React$useState = React__default.useState(-1),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    activeTagIndex = _React$useState2[0],
    setActiveTagIndex = _React$useState2[1];
  var _React$useState3 = React__default.useState(defaultValue !== null && defaultValue !== void 0 ? defaultValue : ''),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    inputValueUncontrolled = _React$useState4[0],
    setInputValueUncontrolled = _React$useState4[1];
  var _useControllableState = useControllableState({
      value: tags,
      defaultValue: [],
      onChange: function onChange(tags) {
        onTagChange === null || onTagChange === void 0 || onTagChange({
          tags: tags
        });
      }
    }),
    _useControllableState2 = _slicedToArray(_useControllableState, 2),
    tagsValue = _useControllableState2[0],
    setTagsValue = _useControllableState2[1];
  var getNewTagsArray = function getNewTagsArray(indexToRemove) {
    var currentTags = tagsValue;
    if (!currentTags) {
      return [];
    }

    // Check if the index is valid
    if (indexToRemove < 0 || indexToRemove >= currentTags.length) {
      return currentTags; // Return the original array
    }

    // Create a new array without the element at the specified index
    var newArray = currentTags.slice(0, indexToRemove).concat(currentTags.slice(indexToRemove + 1));
    return newArray;
  };
  var getTags = React__default.useMemo(function () {
    return function (_ref2) {
      var size = _ref2.size;
      return getTagsGroup({
        size: size,
        tags: tagsValue,
        activeTagIndex: activeTagIndex,
        isDisabled: isDisabled,
        onDismiss: function onDismiss(_ref3) {
          var tagIndex = _ref3.tagIndex;
          setTagsValue(function () {
            return getNewTagsArray(tagIndex);
          });
        }
      });
    };
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [activeTagIndex, tags, tagsValue, isDisabled]);
  var handleTaggedInputChange = function handleTaggedInputChange(_ref4) {
    var value = _ref4.value;
    if (!isTaggedInput) {
      return;
    }
    setInputValueUncontrolled(value !== null && value !== void 0 ? value : '');
  };
  var handleTagsClear = function handleTagsClear() {
    if (!isTaggedInput) {
      return;
    }
    setTagsValue(function () {
      return [];
    });
  };
  var clearInput = function clearInput() {
    var isControlledValue = value !== undefined;
    if (isControlledValue) {
      // In Controlled component, we don't clear input ourselves. We just call onChange with empty value
      onChange === null || onChange === void 0 || onChange({
        name: name,
        value: ''
      });
      return;
    }
    if (!inputRef.current) {
      return;
    }
    setInputValueUncontrolled('');
    if (isReactNative()) {
      setTimeout(function () {
        var _inputRef$current;
        // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error
        // @ts-ignore: clear does exist in react native
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.clear();
      }, 10);
      return;
    }
    inputRef.current.value = '';
  };
  var handleTaggedInputKeydown = function handleTaggedInputKeydown(e) {
    if (!isTaggedInput) {
      return;
    }
    var currentTags = tagsValue;
    var isControlledValue = value !== undefined;
    var inputValue = isControlledValue ? value === null || value === void 0 ? void 0 : value.trim() : inputValueUncontrolled.trim();
    if (e.key === 'Enter' || e.key === ',') {
      var _e$event$preventDefau, _e$event;
      (_e$event$preventDefau = (_e$event = e.event).preventDefault) === null || _e$event$preventDefau === void 0 || _e$event$preventDefau.call(_e$event); // we don't want textarea to treat enter as line break in tagged inputs
      if (inputValue) {
        setTagsValue(function () {
          return [].concat(_toConsumableArray(currentTags), [inputValue]);
        });
        clearInput();
        setActiveTagIndex(-1);
      }
    }
    if (e.key === 'Backspace' && !inputValue && activeTagIndex < 0 && currentTags.length > 0) {
      setTagsValue(function () {
        return currentTags.slice(0, -1);
      });
    }
  };
  return {
    activeTagIndex: activeTagIndex,
    setActiveTagIndex: setActiveTagIndex,
    getTags: getTags,
    handleTaggedInputKeydown: handleTaggedInputKeydown,
    handleTaggedInputChange: handleTaggedInputChange,
    handleTagsClear: handleTagsClear
  };
};

export { useTaggedInput };
//# sourceMappingURL=useTaggedInput.js.map
