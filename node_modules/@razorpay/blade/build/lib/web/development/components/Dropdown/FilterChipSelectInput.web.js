import _typeof from '@babel/runtime/helpers/typeof';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import React__default, { useEffect } from 'react';
import { useDropdown } from './useDropdown.js';
import { dropdownComponentIds } from './dropdownComponentIds.js';
import { useFilterChipGroupContext } from './FilterChipGroupContext.web.js';
import '../../utils/assignWithoutSideEffects/index.js';
import { BaseFilterChip } from '../FilterChip/BaseFilterChip.web.js';
import { getActionListContainerRole } from '../ActionList/getA11yRoles.js';
import { useId } from '../../utils/useId.js';
import { useListViewFilterContext } from '../ListView/ListViewFiltersContext.web.js';
import { useFirstRender } from '../../utils/useFirstRender.js';
import { jsx } from 'react/jsx-runtime';
import { assignWithoutSideEffects } from '../../utils/assignWithoutSideEffects/assignWithoutSideEffects.js';

var _excluded = ["onClick", "onBlur", "onKeyDown", "accessibilityLabel", "testID", "value", "onClearButtonClick", "label", "onChange", "name", "isDisabled"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var _FilterChipSelectInput = function _FilterChipSelectInput(props) {
  var _options$find$title, _options$find;
  var idBase = useId('filter-chip-select-input');
  var _onClick = props.onClick,
    _onBlur = props.onBlur,
    onKeyDown = props.onKeyDown,
    accessibilityLabel = props.accessibilityLabel,
    testID = props.testID,
    value = props.value,
    onClearButtonClick = props.onClearButtonClick,
    label = props.label,
    onChange = props.onChange,
    name = props.name,
    isDisabled = props.isDisabled,
    rest = _objectWithoutProperties(props, _excluded);
  var _React$useState = React__default.useState([]),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    uncontrolledInputValue = _React$useState2[0],
    setUncontrolledInputValue = _React$useState2[1];
  var isFirstRender = useFirstRender();
  var _useDropdown = useDropdown(),
    options = _useDropdown.options,
    selectedIndices = _useDropdown.selectedIndices,
    onTriggerClick = _useDropdown.onTriggerClick,
    onTriggerKeydown = _useDropdown.onTriggerKeydown,
    dropdownBaseId = _useDropdown.dropdownBaseId,
    isOpen = _useDropdown.isOpen,
    activeIndex = _useDropdown.activeIndex,
    hasFooterAction = _useDropdown.hasFooterAction,
    triggererRef = _useDropdown.triggererRef,
    selectionType = _useDropdown.selectionType,
    isControlled = _useDropdown.isControlled,
    setSelectedIndices = _useDropdown.setSelectedIndices,
    controlledValueIndices = _useDropdown.controlledValueIndices,
    changeCallbackTriggerer = _useDropdown.changeCallbackTriggerer;
  var valueTitle = (_options$find$title = (_options$find = options.find(function (option) {
    return option.value === value;
  })) === null || _options$find === void 0 ? void 0 : _options$find.title) !== null && _options$find$title !== void 0 ? _options$find$title : value;
  var isUnControlled = options.length > 0 && props.value === undefined;
  // Currently we are having 2 context for selectedFilters. One is for FilterChipGroup and other is for  ListView
  var _useListViewFilterCon = useListViewFilterContext(),
    listViewSelectedFilters = _useListViewFilterCon.listViewSelectedFilters,
    setListViewSelectedFilters = _useListViewFilterCon.setListViewSelectedFilters;
  var _useFilterChipGroupCo = useFilterChipGroupContext(),
    clearFilterCallbackTriggerer = _useFilterChipGroupCo.clearFilterCallbackTriggerer,
    setFilterChipGroupSelectedFilters = _useFilterChipGroupCo.setFilterChipGroupSelectedFilters;
  var getValuesArrayFromIndices = function getValuesArrayFromIndices() {
    var indices = [];
    if (isControlled) {
      indices = controlledValueIndices;
    } else {
      indices = selectedIndices;
    }
    return indices.map(function (selectionIndex) {
      return options[selectionIndex].value;
    });
  };
  useEffect(function () {
    var valueNotEmpty = typeof value === 'string' && value.trim() !== '' || Array.isArray(value) && value.length > 0;
    // since we need to sync state only one time so skipping value checking.
    var isValueAndSelectedOptoinsSynced = typeof value === 'string' && value && selectedIndices.length === 1 || Array.isArray(value) && value.length === selectedIndices.length;
    if (isUnControlled) {
      if (listViewSelectedFilters[label]) {
        var _value = listViewSelectedFilters[label];
        setSelectedIndices(_value);
        var inputValue = _value.map(function (selectionIndex) {
          return options[selectionIndex].value;
        });
        setUncontrolledInputValue(inputValue);
        setFilterChipGroupSelectedFilters(function (prev) {
          return prev.includes(label) ? prev : [].concat(_toConsumableArray(prev), [label]);
        });
      }
    } else if (listViewSelectedFilters[label]) {
      var _value2 = listViewSelectedFilters[label];
      setSelectedIndices(_value2);
      // This would be the case when filterChipSelectInput is controlled and are being opened first time
    } else if (valueNotEmpty && !isValueAndSelectedOptoinsSynced && options.length > 0) {
      var _selectedIndices = typeof value === 'string' ? [options.findIndex(function (option) {
        return option.value === value;
      })] : options.map(function (option, index) {
        return value.includes(option.value) ? index : -1;
      }).filter(function (index) {
        return index !== -1;
      });
      setSelectedIndices(_selectedIndices);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isUnControlled, options]);
  var getTitleFromValue = function getTitleFromValue(value) {
    var option = options.find(function (option) {
      return option.value === value;
    });
    return option ? option.title : '';
  };
  var getUnControlledFilterChipValue = function getUnControlledFilterChipValue() {
    if (selectionType === 'single') {
      if (uncontrolledInputValue.length > 0) {
        return getTitleFromValue(uncontrolledInputValue[0]);
      }
      return '';
    }
    return uncontrolledInputValue;
  };
  var handleClearButtonClick = function handleClearButtonClick() {
    var _props$onClearButtonC, _props$onChange;
    (_props$onClearButtonC = props.onClearButtonClick) === null || _props$onClearButtonC === void 0 || _props$onClearButtonC.call(props, {
      name: name !== null && name !== void 0 ? name : idBase,
      values: getValuesArrayFromIndices()
    });
    (_props$onChange = props.onChange) === null || _props$onChange === void 0 || _props$onChange.call(props, {
      name: name !== null && name !== void 0 ? name : idBase,
      values: []
    });
    if (isUnControlled) {
      setUncontrolledInputValue([]);
      setSelectedIndices([]);
    }
    setFilterChipGroupSelectedFilters(function (prev) {
      return prev.filter(function (filter) {
        return filter !== label;
      });
    });
    setListViewSelectedFilters(function (prev) {
      var _ = prev[label],
        updatedFilters = _objectWithoutProperties(prev, [label].map(_toPropertyKey));
      return updatedFilters;
    });
    setSelectedIndices([]);
  };
  useEffect(function () {
    if (clearFilterCallbackTriggerer) {
      handleClearButtonClick();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [clearFilterCallbackTriggerer]);
  useEffect(function () {
    if (!isFirstRender) {
      var _props$onChange2;
      (_props$onChange2 = props.onChange) === null || _props$onChange2 === void 0 || _props$onChange2.call(props, {
        name: props.name || idBase,
        values: getValuesArrayFromIndices()
      });
      if (isUnControlled) {
        setUncontrolledInputValue(getValuesArrayFromIndices());
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [changeCallbackTriggerer]);
  useEffect(function () {
    var isValueEmpty = selectedIndices.length === 0;
    if (!isFirstRender && !isValueEmpty) {
      setFilterChipGroupSelectedFilters(function (prev) {
        return prev.includes(label) ? prev : [].concat(_toConsumableArray(prev), [label]);
      });
      setListViewSelectedFilters(function (prev) {
        return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, label, selectedIndices));
      });
    } else if (!isFirstRender && isValueEmpty) {
      setFilterChipGroupSelectedFilters(function (prev) {
        return prev.filter(function (filter) {
          return filter !== label;
        });
      });
      setListViewSelectedFilters(function (prev) {
        var _ = prev[label],
          updatedFilters = _objectWithoutProperties(prev, [label].map(_toPropertyKey));
        return updatedFilters;
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [changeCallbackTriggerer]);
  var handleKeyDown = function handleKeyDown(e) {
    onKeyDown === null || onKeyDown === void 0 || onKeyDown(e);
    onTriggerKeydown === null || onTriggerKeydown === void 0 || onTriggerKeydown({
      event: e
    });
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopPropagation();
    }
    if ((e.key === 'Enter' || e.key === ' ') && !isOpen) {
      e.preventDefault();
      e.stopPropagation();
      onTriggerClick();
    }
  };
  return /*#__PURE__*/jsx(BaseFilterChip, _objectSpread(_objectSpread({
    label: label,
    value: valueTitle !== null && valueTitle !== void 0 ? valueTitle : getUnControlledFilterChipValue(),
    onClearButtonClick: handleClearButtonClick,
    selectionType: selectionType
  }, rest), {}, {
    ref: triggererRef,
    onKeyDown: handleKeyDown,
    accessibilityProps: {
      label: accessibilityLabel !== null && accessibilityLabel !== void 0 ? accessibilityLabel : label,
      hasPopup: getActionListContainerRole(hasFooterAction, 'FilterChipSelectInput'),
      expanded: isOpen,
      controls: "".concat(dropdownBaseId, "-actionlist"),
      activeDescendant: activeIndex >= 0 ? "".concat(dropdownBaseId, "-").concat(activeIndex) : undefined
    },
    onClick: function onClick(e) {
      onTriggerClick();
      _onClick === null || _onClick === void 0 || _onClick(e);
    },
    onBlur: function onBlur(e) {
      _onBlur === null || _onBlur === void 0 || _onBlur(e);
    },
    isDisabled: isDisabled
  }));
};
var FilterChipSelectInput = /*#__PURE__*/assignWithoutSideEffects(_FilterChipSelectInput, {
  componentId: dropdownComponentIds.triggers.FilterChipSelectInput
});

export { FilterChipSelectInput };
//# sourceMappingURL=FilterChipSelectInput.web.js.map
