import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { useRef } from 'react';
import { useUncontrolled } from '@mantine/hooks';
import { shiftTimezone } from './shiftTimezone.js';
import '../../utils/logger/index.js';
import { throwBladeError } from '../../utils/logger/logger.js';

var getEmptyValue = function getEmptyValue(type) {
  return type === 'range' ? [null, null] : type === 'multiple' ? [] : null;
};
function useUncontrolledDates(_ref) {
  var type = _ref.type,
    value = _ref.value,
    defaultValue = _ref.defaultValue,
    _onChange = _ref.onChange;
  var storedType = useRef(type);
  var _useUncontrolled = useUncontrolled({
      value: shiftTimezone('add', value),
      defaultValue: shiftTimezone('add', defaultValue),
      finalValue: getEmptyValue(type),
      onChange: function onChange(newDate) {
        _onChange === null || _onChange === void 0 || _onChange(shiftTimezone('remove', newDate));
      }
    }),
    _useUncontrolled2 = _slicedToArray(_useUncontrolled, 3),
    _value = _useUncontrolled2[0],
    _setValue = _useUncontrolled2[1],
    controlled = _useUncontrolled2[2];
  var _finalValue = _value;
  if (storedType.current !== type) {
    // Type has changed. Do some checks or resets

    storedType.current = type;
    if (value === undefined) {
      // Reset uncontrolled value as types aren't compatible
      _finalValue = defaultValue !== undefined ? defaultValue : getEmptyValue(type);
      _setValue(_finalValue);
    } else if (true) {
      // Throw errors in dev mode in case type of value isn't correct
      switch (type) {
        case 'default':
          if (value !== null && typeof value !== 'string') {
            throwBladeError({
              message: 'Value must be type of `null` or `string`',
              moduleName: 'useControlledDates'
            });
          }
          break;
        case 'multiple':
          if (!(value instanceof Array)) {
            throwBladeError({
              message: 'Value must be type of `string[]`',
              moduleName: 'useControlledDates'
            });
          }
          break;
        case 'range':
          if (!(value instanceof Array) || value.length !== 2) {
            throwBladeError({
              message: 'Value must be type of `[string, string]`',
              moduleName: 'useControlledDates'
            });
          }
          break;
      }
    }
  }
  return [_finalValue, _setValue, controlled];
}

export { useUncontrolledDates };
//# sourceMappingURL=useControlledDates.js.map
