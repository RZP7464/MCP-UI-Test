import _typeof from '@babel/runtime/helpers/typeof';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import isObject from '../lodashButBetter/isObject.js';
import '../logger/index.js';
import { logger } from '../logger/logger.js';

var isPartialMatchObjectKeys = function isPartialMatchObjectKeys(_ref) {
  var objectToMatch = _ref.objectToMatch,
    objectToInspect = _ref.objectToInspect;
  var matchResponses = [];
  var _matchObjectKeys = function matchObjectKeys(_ref2) {
    var innerObjectToMatch = _ref2.innerObjectToMatch,
      innerObjectToInspect = _ref2.innerObjectToInspect;
    for (var _i = 0, _Object$entries = Object.entries(innerObjectToMatch); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        valueToMatch = _Object$entries$_i[1];
      var valueToInspect = innerObjectToInspect[key];
      if (innerObjectToInspect.hasOwnProperty(key)) {
        if (valueToMatch === null || valueToMatch === undefined || valueToMatch === '' || Array.isArray(valueToMatch) ||
        // the condition checks if the "valueToMatch" is not of type object then "valueToMatch" type should be same as type of "valueToInspect"
        !(valueToMatch instanceof Object) && _typeof(valueToMatch) !== _typeof(valueToInspect)) {
          if (false) {
            // this is an invalid case, so we log error
            logger({
              message: "Unexpected value: ".concat(JSON.stringify(valueToMatch), " of type ").concat(_typeof(valueToMatch), " for key: ").concat(key),
              moduleName: 'isPartialMatchObjectKeys',
              type: 'error'
            });
          }
          matchResponses.push(false);
        }
        if (typeof valueToMatch === 'string') {
          // we have reached leaf node of the objectToMatch(i.e sub-object)
          matchResponses.push(true);
        }
        if (isObject(valueToMatch) && isObject(valueToInspect)) {
          // let's go inside further and do a nested check
          _matchObjectKeys({
            innerObjectToMatch: valueToMatch,
            innerObjectToInspect: valueToInspect
          });
        }
      } else {
        if (false) {
          // the key doesn't exist in the innerObjectToMatch, so we log error
          logger({
            message: "".concat(key, " doesn't exist in ").concat(JSON.stringify(innerObjectToInspect, null, 2)),
            moduleName: 'isPartialMatchObjectKeys',
            type: 'error'
          });
        }
        matchResponses.push(false);
      }
    }
  };
  _matchObjectKeys({
    innerObjectToMatch: objectToMatch,
    innerObjectToInspect: objectToInspect
  });
  return matchResponses.every(Boolean);
};

export { isPartialMatchObjectKeys };
//# sourceMappingURL=isPartialMatchObjectKeys.js.map
