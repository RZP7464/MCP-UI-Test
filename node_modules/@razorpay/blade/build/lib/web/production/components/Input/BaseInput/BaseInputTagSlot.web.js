import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import React__default from 'react';
import styled from 'styled-components';
import { baseInputHeight } from './baseInputTokens.js';
import '../../Box/BaseBox/index.js';
import '../../Typography/index.js';
import '../../../utils/index.js';
import { useIsomorphicLayoutEffect } from '../../../utils/useIsomorphicLayoutEffect.js';
import { useIsMobile } from '../../../utils/useIsMobile.js';
import '../../../utils/metaAttribute/index.js';
import '../../../tokens/global/index.js';
import { useTableEditableCell } from '../../Table/TableEditableCellContext.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { size } from '../../../tokens/global/size.js';
import { MetaConstants } from '../../../utils/metaAttribute/metaConstants.js';
import { BaseBox } from '../../Box/BaseBox/BaseBox.web.js';
import { Text } from '../../Typography/Text/Text.js';
import { makeSize } from '../../../utils/makeSize/makeSize.js';
import { castWebType } from '../../../utils/platform/castUtils.js';

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var MINUMUM_INPUT_SPACE = 60;
var PLUS_X_MORE_TEXT_WIDTH = 60;
var TAG_MAX_WIDTH = size['140'];
var useVisibleTagsCount = function useVisibleTagsCount(_ref) {
  var slotRef = _ref.slotRef,
    tags = _ref.tags,
    maxTagRows = _ref.maxTagRows,
    visibleTagsCountRef = _ref.visibleTagsCountRef,
    showAllTags = _ref.showAllTags,
    labelPrefix = _ref.labelPrefix;
  var _React$useState = React__default.useState(0),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    visibleTagsCount = _React$useState2[0],
    setVisibleTagsCount = _React$useState2[1];
  var visibleTagsCountStateRef = React__default.useRef(0);
  var _useTableEditableCell = useTableEditableCell(),
    isInsideTableEditableCell = _useTableEditableCell.isInsideTableEditableCell;
  useIsomorphicLayoutEffect(function () {
    var _slotRef$current, _slotRef$current2;
    if (!tags || labelPrefix || isInsideTableEditableCell) {
      setVisibleTagsCount(0);
      return;
    }
    if (maxTagRows === 'multiple' || showAllTags) {
      visibleTagsCountRef.current = tags.length;
      setVisibleTagsCount(tags.length);
      return;
    }
    var inputTagsSlotWidth = (_slotRef$current = slotRef.current) === null || _slotRef$current === void 0 ? void 0 : _slotRef$current.clientWidth;
    visibleTagsCountStateRef.current = 0;
    var totalTagsWidth = 0;
    if (!inputTagsSlotWidth) {
      return;
    }
    var allTagsEl = (_slotRef$current2 = slotRef.current) === null || _slotRef$current2 === void 0 ? void 0 : _slotRef$current2.querySelectorAll("[data-blade-component=\"".concat(MetaConstants.Tag, "\"]"));
    var totalAvailableSpaceForTags = inputTagsSlotWidth - (MINUMUM_INPUT_SPACE + PLUS_X_MORE_TEXT_WIDTH);
    if (allTagsEl.length !== tags.length) {
      // some weird edge cases in controlled select where tags are not rendered in children
      // we assume 140px (max-width of tag as width of all tags)
      var tagsCount = Math.floor(totalAvailableSpaceForTags / TAG_MAX_WIDTH * tags.length);
      visibleTagsCountRef.current = tagsCount;
      setVisibleTagsCount(tagsCount);
      return;
    }
    var _iterator = _createForOfIteratorHelper(allTagsEl),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var tagEl = _step.value;
        totalTagsWidth += tagEl.clientWidth;
        if (totalTagsWidth >= totalAvailableSpaceForTags) {
          break;
        } else {
          visibleTagsCountStateRef.current++;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    visibleTagsCountRef.current = visibleTagsCountStateRef.current;
    setVisibleTagsCount(visibleTagsCountStateRef.current);
  }, [tags === null || tags === void 0 ? void 0 : tags.length, showAllTags]);
  return visibleTagsCount;
};
var getSelectedTextWithoutTags = function getSelectedTextWithoutTags(_ref2) {
  var items = _ref2.items,
    labelPrefix = _ref2.labelPrefix;
  if (labelPrefix) {
    return "".concat(labelPrefix, " (").concat(items, " Selected)");
  }
  return "".concat(items, " Selected");
};
var TagSlotContainer = /*#__PURE__*/styled(BaseBox).withConfig({
  displayName: "BaseInputTagSlotweb__TagSlotContainer",
  componentId: "sc-1bt1h3t-0"
})(function () {
  return {
    // hides the scrollbar of tagslot
    '::-webkit-scrollbar': {
      display: 'none'
    },
    '-ms-overflow-style': 'none',
    'scrollbar-width': 'none'
  };
});
var SelectedCountText = function SelectedCountText(_ref3) {
  var children = _ref3.children,
    isDisabled = _ref3.isDisabled;
  return /*#__PURE__*/jsx(Text, {
    color: isDisabled ? 'surface.text.gray.disabled' : 'surface.text.gray.subtle',
    alignSelf: "center",
    marginY: "spacing.2",
    marginRight: "spacing.4",
    variant: "body",
    size: "small",
    weight: "regular",
    children: /*#__PURE__*/jsx(BaseBox, {
      as: "span",
      whiteSpace: "nowrap",
      children: children
    })
  });
};
var BaseInputTagSlot = function BaseInputTagSlot(_ref4) {
  var renderAs = _ref4.renderAs,
    children = _ref4.children,
    tags = _ref4.tags,
    maxTagRows = _ref4.maxTagRows,
    showAllTags = _ref4.showAllTags,
    setShouldIgnoreBlurAnimation = _ref4.setShouldIgnoreBlurAnimation,
    handleOnInputClick = _ref4.handleOnInputClick,
    isDropdownTrigger = _ref4.isDropdownTrigger,
    visibleTagsCountRef = _ref4.visibleTagsCountRef,
    labelPrefix = _ref4.labelPrefix,
    isDisabled = _ref4.isDisabled,
    numberOfLines = _ref4.numberOfLines,
    isTextArea = _ref4.isTextArea,
    size$1 = _ref4.size;
  var hasTags = tags && tags.length > 0;
  var slotRef = React__default.useRef(null);
  var _useTableEditableCell2 = useTableEditableCell(),
    isInsideTableEditableCell = _useTableEditableCell2.isInsideTableEditableCell;
  var visibleTagsCount = useVisibleTagsCount({
    slotRef: slotRef,
    tags: tags,
    maxTagRows: maxTagRows,
    visibleTagsCountRef: visibleTagsCountRef,
    showAllTags: showAllTags,
    labelPrefix: labelPrefix
  });
  React__default.useEffect(function () {
    var _slotRef$current3, _slotRef$current3$scr;
    (_slotRef$current3 = slotRef.current) === null || _slotRef$current3 === void 0 || (_slotRef$current3$scr = _slotRef$current3.scrollTo) === null || _slotRef$current3$scr === void 0 || _slotRef$current3$scr.call(_slotRef$current3, {
      top: maxTagRows === 'multiple' || maxTagRows === 'expandable' ? slotRef.current.scrollHeight : 0,
      left: maxTagRows === 'single' ? slotRef.current.scrollWidth : 0,
      behavior: 'smooth'
    });
  }, [tags === null || tags === void 0 ? void 0 : tags.length, maxTagRows]);
  React__default.useEffect(function () {
    if (!showAllTags) {
      var _slotRef$current4, _slotRef$current4$scr;
      (_slotRef$current4 = slotRef.current) === null || _slotRef$current4 === void 0 || (_slotRef$current4$scr = _slotRef$current4.scrollTo) === null || _slotRef$current4$scr === void 0 || _slotRef$current4$scr.call(_slotRef$current4, {
        top: 0,
        left: 0,
        behavior: 'smooth'
      });
    } else if (maxTagRows === 'single') {
      var _slotRef$current5, _slotRef$current5$scr;
      // when its single line input and showAllTags is true, we scroll till item on focus
      (_slotRef$current5 = slotRef.current) === null || _slotRef$current5 === void 0 || (_slotRef$current5$scr = _slotRef$current5.scrollTo) === null || _slotRef$current5$scr === void 0 || _slotRef$current5$scr.call(_slotRef$current5, {
        top: 0,
        left: maxTagRows === 'single' ? slotRef.current.scrollWidth : 0,
        behavior: 'smooth'
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [showAllTags]);
  var visibleTags = React__default.useMemo(function () {
    return showAllTags ? tags : tags === null || tags === void 0 ? void 0 : tags.slice(0, visibleTagsCount);
  }, [showAllTags, tags, visibleTagsCount]);
  var invisibleTagsCount = React__default.useMemo(function () {
    if (tags && visibleTags) {
      return tags.length - visibleTags.length;
    }
    return 0;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tags === null || tags === void 0 ? void 0 : tags.length, visibleTags === null || visibleTags === void 0 ? void 0 : visibleTags.length]);
  var isMobile = useIsMobile();
  if (!isDropdownTrigger) {
    // If its not dropdown trigger, we don't need to render tag containers
    return children;
  }

  // tag height changes in mobile and desktop so we keep different paddings to make it look as expected
  var paddingYWithTags = isMobile ? 'spacing.1' : 'spacing.2';
  return /*#__PURE__*/jsxs(TagSlotContainer, {
    ref: slotRef,
    className: "tags-slot",
    paddingY: paddingYWithTags,
    paddingLeft: "spacing.4",
    display: "flex",
    flex: "1",
    flexWrap: maxTagRows === 'single' ? 'nowrap' : 'wrap',
    overflowX: "auto",
    overflowY: showAllTags || maxTagRows === 'multiple' ? 'auto' : 'hidden',
    minHeight: makeSize(baseInputHeight[size$1]),
    maxHeight:
    // In TextArea with tagged input, we explicitly define maxHeight based on maxHeight so that tags dont overflow out of textarea
    // And In table we strictly want the maxHeight to be defined to not mess up the table layout
    isDropdownTrigger && isTextArea || isInsideTableEditableCell ? makeSize(baseInputHeight[size$1] * (numberOfLines !== null && numberOfLines !== void 0 ? numberOfLines : 1)) : undefined,
    onMouseDown: function onMouseDown() {
      setShouldIgnoreBlurAnimation === null || setShouldIgnoreBlurAnimation === void 0 || setShouldIgnoreBlurAnimation(true);
    },
    onClick: function onClick(e) {
      handleOnInputClick(castWebType(e));
    },
    onMouseUp: function onMouseUp() {
      setShouldIgnoreBlurAnimation === null || setShouldIgnoreBlurAnimation === void 0 || setShouldIgnoreBlurAnimation(false);
    },
    children: [isInsideTableEditableCell && tags && tags.length > 0 ? /*#__PURE__*/jsx(SelectedCountText, {
      isDisabled: isDisabled,
      children: getSelectedTextWithoutTags({
        items: tags.length,
        labelPrefix: labelPrefix
      })
    }) : /*#__PURE__*/jsxs(Fragment, {
      children: [visibleTags, tags && !showAllTags && invisibleTagsCount ? /*#__PURE__*/jsx(SelectedCountText, {
        isDisabled: isDisabled,
        children: (visibleTags === null || visibleTags === void 0 ? void 0 : visibleTags.length) === 0 ? getSelectedTextWithoutTags({
          items: invisibleTagsCount,
          labelPrefix: labelPrefix
        }) : "+".concat(invisibleTagsCount, " More")
      }) : null]
    }), /*#__PURE__*/jsx(BaseBox, {
      marginTop: "-4px",
      minWidth: hasTags && renderAs === 'button' ? undefined : "min(20%, ".concat(makeSize(MINUMUM_INPUT_SPACE), ")"),
      width: hasTags && renderAs === 'button' ? makeSize(size['1']) : '100%',
      children: children
    })]
  });
};

export { BaseInputTagSlot };
//# sourceMappingURL=BaseInputTagSlot.web.js.map
