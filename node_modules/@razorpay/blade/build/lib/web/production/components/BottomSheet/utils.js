import _slicedToArray from '@babel/runtime/helpers/slicedToArray';

/* eslint-disable @typescript-eslint/explicit-function-return-type */

// Taken from:
// https://github.com/bottom-sheet/state-machine/blob/main/src/utils.ts
function computeSnapPointBounds(unsafeHeight, snapPoints) {
  var height = Math.round(unsafeHeight);
  if (!Number.isFinite(height) || height <= 0) {
    return [0, 0, 0];
  }
  var _snapPoints = _slicedToArray(snapPoints, 1),
    minSnap = _snapPoints[0];
  var nearest = snapPoints.reduce(function (prev, curr) {
    return Math.abs(curr - height) < Math.abs(prev - height) ? curr : prev;
  }, minSnap);
  var nearestIndex = snapPoints.indexOf(nearest);
  var lower = snapPoints[Math.max(nearestIndex - 1, 0)];
  var upper = snapPoints[Math.min(nearestIndex + 1, snapPoints.length - 1)];
  return [nearest, lower, upper];
}
function computeMinContent(_ref) {
  var maxHeight = _ref.maxHeight,
    headerHeight = _ref.headerHeight,
    footerHeight = _ref.footerHeight;
  var minHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;
  return Math.min(maxHeight, Math.max(headerHeight + footerHeight, minHeight));
}
function computeMaxContent(_ref2, minHeight) {
  var maxHeight = _ref2.maxHeight,
    headerHeight = _ref2.headerHeight,
    contentHeight = _ref2.contentHeight,
    footerHeight = _ref2.footerHeight;
  return Math.min(maxHeight, Math.max(headerHeight + contentHeight + footerHeight, computeMinContent({
    maxHeight: maxHeight,
    headerHeight: headerHeight,
    footerHeight: footerHeight
  }, minHeight)));
}

export { computeMaxContent, computeMinContent, computeSnapPointBounds };
//# sourceMappingURL=utils.js.map
