import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import React__default from 'react';
import styled from 'styled-components';
import getIn from '../../../utils/lodashButBetter/get.js';
import '../../../utils/index.js';
import '../../VisuallyHidden/index.web.js';
import '../../../utils/assignWithoutSideEffects/index.js';
import '../../../utils/makeMotionTime/index.web.js';
import '../../../utils/makeAccessible/index.js';
import { useMergeRefs } from '../../../utils/useMergeRefs.js';
import '../../../utils/getFocusRingStyles/index.js';
import '../../../utils/makeAnalyticsAttribute/index.js';
import { jsx } from 'react/jsx-runtime';
import { castWebType } from '../../../utils/platform/castUtils.js';
import { makeMotionTime } from '../../../utils/makeMotionTime/makeMotionTime.web.js';
import { screenReaderStyles } from '../../VisuallyHidden/ScreenReaderStyles.js';
import { getFocusRingStyles } from '../../../utils/getFocusRingStyles/getFocusRingStyles.web.js';
import { makeAccessible } from '../../../utils/makeAccessible/makeAccessible.web.js';
import { makeAnalyticsAttribute } from '../../../utils/makeAnalyticsAttribute/makeAnalyticsAttribute.js';
import { assignWithoutSideEffects } from '../../../utils/assignWithoutSideEffects/assignWithoutSideEffects.js';

var _excluded = ["id", "inputProps", "isChecked", "isDisabled", "hasError", "hoverTokens", "tabIndex", "accessibilityLabel"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var getHoverStyles = function getHoverStyles(_ref) {
  var _hoverTokens$default$;
  var theme = _ref.theme,
    isDisabled = _ref.isDisabled,
    hasError = _ref.hasError,
    isChecked = _ref.isChecked,
    hoverTokens = _ref.hoverTokens;
  if (isDisabled || hasError) return {};
  var checked = isChecked ? 'checked' : 'unchecked';
  var backgroundColor = hoverTokens["default"].background[checked];
  var borderColor = (_hoverTokens$default$ = hoverTokens["default"].border) === null || _hoverTokens$default$ === void 0 ? void 0 : _hoverTokens$default$[checked];
  return {
    borderColor: borderColor ? getIn(theme, borderColor) : undefined,
    backgroundColor: getIn(theme, backgroundColor),
    transitionTimingFunction: theme.motion.easing.standard,
    transitionDuration: castWebType(makeMotionTime(theme.motion.duration['2xquick']))
  };
};
var StyledInput = /*#__PURE__*/styled.input.withConfig({
  displayName: "SelectorInputweb__StyledInput",
  componentId: "sc-1bnkrae-0"
})(function (_ref2) {
  var theme = _ref2.theme,
    isChecked = _ref2.isChecked,
    isDisabled = _ref2.isDisabled,
    hasError = _ref2.hasError,
    hoverTokens = _ref2.hoverTokens;
  return _objectSpread(_objectSpread({}, screenReaderStyles), {}, {
    '&:focus-visible + div': _objectSpread({}, getFocusRingStyles({
      theme: theme
    })),
    '&:hover + div': _objectSpread({}, getHoverStyles({
      theme: theme,
      isChecked: isChecked,
      isDisabled: isDisabled,
      hasError: hasError,
      hoverTokens: hoverTokens
    }))
  });
});
var _SelectorInput = function _SelectorInput(_ref3, ref) {
  var id = _ref3.id,
    inputProps = _ref3.inputProps,
    isChecked = _ref3.isChecked,
    isDisabled = _ref3.isDisabled,
    hasError = _ref3.hasError,
    hoverTokens = _ref3.hoverTokens,
    tabIndex = _ref3.tabIndex,
    accessibilityLabel = _ref3.accessibilityLabel,
    rest = _objectWithoutProperties(_ref3, _excluded);
  // merging both refs because inputProps.ref needs to have access to indeterminate state
  // to be able to set the mixed value via setMixed() function
  // TODO: replace with a generic `mergeRefs()` util if we do this in other places
  var mergedRef = useMergeRefs(ref, inputProps.ref);
  return /*#__PURE__*/jsx(StyledInput, _objectSpread(_objectSpread(_objectSpread(_objectSpread({
    id: id,
    isChecked: isChecked,
    isDisabled: isDisabled,
    hasError: hasError,
    tabIndex: tabIndex,
    hoverTokens: hoverTokens
  }, inputProps), makeAccessible({
    label: accessibilityLabel
  })), makeAnalyticsAttribute(rest)), {}, {
    ref: mergedRef
  }));
};
var SelectorInput = /*#__PURE__*/assignWithoutSideEffects(/*#__PURE__*/React__default.forwardRef(_SelectorInput), {
  displayName: 'SelectorInput'
});

export { SelectorInput };
//# sourceMappingURL=SelectorInput.web.js.map
