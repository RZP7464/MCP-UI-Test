{"version":3,"file":"useFormattedInput.js","sources":["../../../../../../../src/components/Input/TextInput/useFormattedInput.ts"],"sourcesContent":["import type React from 'react';\nimport { useCallback, useRef, useState, useEffect, useMemo } from 'react';\nimport type { FormInputOnEvent } from '~components/Form/FormTypes';\n\n/**\n * Formats user input according to pattern. format(\"1234\", \"##/##\") → \"12/34\"\n */\nconst format = (value: string, pattern: string): string => {\n  if (!pattern) return value;\n\n  let result = '';\n  let valueIndex = 0;\n\n  for (let i = 0; i < pattern.length; i++) {\n    const patternChar = pattern[i]; // \"#\" or \"/\"\n\n    if (patternChar === '#') {\n      if (valueIndex < value.length) {\n        result += value[valueIndex]; // add \"1\" from \"1234\"\n        valueIndex++;\n      } else {\n        break; // No more input chars, stop\n      }\n    } else {\n      result += patternChar; // add \"/\" delimiter\n    }\n  }\n\n  return result; // \"12/34\"\n};\n\n/**\n * Removes delimiters, keeps only user input. stripPatternCharacters(\"12/34\") → \"1234\"\n */\nconst stripPatternCharacters = (value: string): string => {\n  return value.replace(/[^\\dA-z]/g, ''); // \"12/34\" → \"1234\" (removes \"/\")\n};\n\n/**\n * Checks if character is user input vs delimiter. isUserCharacter('1') → true, isUserCharacter('/') → false\n */\nconst isUserCharacter = (character: string): boolean => {\n  return /[\\dA-z]/.test(character); // \"1\" → true, \"/\" → false\n};\n\ntype UseFormattedInputProps = {\n  format?: string;\n  onChange?: (params: { name?: string; value?: string; rawValue?: string }) => void;\n  value?: string;\n  defaultValue?: string;\n};\n\ntype UseFormattedInputReturn = {\n  formattedValue: string;\n  handleChange: FormInputOnEvent;\n  handleKeyDown: (event: React.KeyboardEvent<HTMLInputElement>) => void;\n  maxLength?: number;\n};\n\n/**\n * Hook for pattern-based input formatting with smart cursor positioning.\n * useFormattedInput({ format: \"##/##\" }) transforms \"1234\" → \"12/34\"\n */\nexport const useFormattedInput = ({\n  format: pattern,\n  onChange,\n  value: userValue,\n  defaultValue = '',\n}: UseFormattedInputProps): UseFormattedInputReturn => {\n  const initialValue = useMemo(() => {\n    return format(userValue ?? defaultValue, pattern ?? '');\n  }, [userValue, defaultValue, pattern]);\n\n  const [internalValue, setInternalValue] = useState(initialValue);\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const infoRef = useRef<{\n    cursorPosition?: number;\n    endOfSection?: boolean;\n  }>({});\n\n  const maxLength = useMemo(() => pattern?.length, [pattern]);\n\n  // Reset internal state when parent clears value (form resets, external state changes)\n  // Preserves format delimiters for visual guidance. Example: \"(###)\" → \"(   )\" when cleared\n  useEffect(() => {\n    if ((userValue === '' || userValue === undefined) && defaultValue === '') {\n      const emptyFormatted = format('', pattern ?? '');\n      setInternalValue(emptyFormatted);\n    }\n    // DATEPICKER FIX: Sync internal state when external value changes\n    // This addresses the issue where DatePicker programmatically updates the value prop\n    // (e.g., when user selects date from calendar), but the formatted input's internal\n    // state doesn't update, causing the input to not reflect the new value.\n    // Without this, only user typing and empty resets were handled.\n    if (userValue !== undefined && userValue !== '' && pattern) {\n      const rawValue = stripPatternCharacters(userValue);\n      const newFormatted = format(rawValue, pattern);\n\n      // Only update if the formatted value actually changed to avoid unnecessary re-renders\n      if (newFormatted !== internalValue) {\n        setInternalValue(newFormatted);\n      }\n    }\n  }, [userValue, pattern]);\n\n  // Apply calculated cursor position after value updates\n  useEffect(() => {\n    const { cursorPosition, endOfSection } = infoRef.current;\n\n    if (endOfSection || cursorPosition === undefined) return; // Skip if no position or end section\n\n    if (inputRef.current) {\n      inputRef.current.setSelectionRange(cursorPosition, cursorPosition);\n    }\n  }, [internalValue]);\n\n  const handleChange: FormInputOnEvent = useCallback(\n    ({ name, value: inputValue }) => {\n      if (!pattern) {\n        // No pattern = regular input\n        const cleanValue = inputValue ?? '';\n        onChange?.({ name, value: cleanValue });\n        setInternalValue(cleanValue);\n        return;\n      }\n\n      const currentValue = internalValue; // \"12/34\" (user wants to delete \"/\")\n      const newInputValue = inputValue ?? ''; // \"1234\" (after deleting \"/\")\n      const cursorPosition = inputRef.current?.selectionStart ?? 0; // 2 (cursor where \"/\" was)\n      const didDelete = newInputValue.length < currentValue.length; // 4 < 5 → true\n\n      infoRef.current.cursorPosition = cursorPosition;\n\n      let rawValue = stripPatternCharacters(newInputValue); // \"1234\" → \"1234\"\n\n      // Handle special case: user deleted a delimiter (like deleting \"/\" in \"12/|34\")\n      if (didDelete) {\n        const deletedChar = currentValue[cursorPosition] ?? ''; // \"12/34\"[2] → \"/\"\n        const deletedDelimiter = !isUserCharacter(deletedChar); // \"/\" → true (is delimiter)\n\n        if (deletedDelimiter) {\n          // true (will execute for \"/\" deletion)\n          const beforeCursor = newInputValue.substring(0, cursorPosition); // \"12\" (before cursor)\n          const afterCursor = newInputValue.substring(cursorPosition); // \"34\" (after cursor)\n          const rawBefore = stripPatternCharacters(beforeCursor); // \"12\" → \"12\"\n          const rawAfter = stripPatternCharacters(afterCursor); // \"34\" → \"34\"\n\n          rawValue = rawBefore.slice(0, -1) + rawAfter; // \"12\".slice(0,-1) + \"34\" → \"1\" + \"34\" → \"134\"\n\n          // Removes trailing non-alphanumeric characters from the end of the string, preserving the last alphanumeric word before them.\n          infoRef.current.cursorPosition =\n            beforeCursor.replace(/([\\d\\w]+)[^\\dA-z]+$/, '$1').length - 1;\n        }\n      }\n\n      const formattedValue = format(rawValue, pattern); // format(\"134\", \"##/##\") → \"13/4\"\n      infoRef.current.endOfSection = false;\n\n      // Handle cursor positioning when typing (not deleting)\n      if (!didDelete) {\n        // User types \"2\" in \"1|\" → becomes \"12|/\" → should jump to \"12/|\"\n        const nextChar = formattedValue[cursorPosition]; // \"12/\"[2] → \"/\" (delimiter)\n        const nextIsDelimiter = nextChar ? !isUserCharacter(nextChar) : false; // \"/\" → true\n\n        const remainingText = formattedValue.substring(cursorPosition); // \"12/\".substring(2) → \"/\"\n        const nextUserCharIndex = remainingText.search(/[\\dA-z]/); // \"/\".search() → -1 (no user chars)\n        const hasMoreUserChars = nextUserCharIndex !== -1; // -1 !== -1 → false\n\n        infoRef.current.endOfSection = nextIsDelimiter && !hasMoreUserChars; // true && false → false\n\n        // Move cursor past auto-inserted delimiters for smooth typing\n        if (nextIsDelimiter && hasMoreUserChars) {\n          const prevChar = formattedValue[cursorPosition - 1] ?? '';\n          const prevIsDelimiter = !isUserCharacter(prevChar);\n\n          if (prevIsDelimiter) {\n            infoRef.current.cursorPosition = cursorPosition + nextUserCharIndex + 1;\n          } else {\n            // If we're at a delimiter after typing (not deleting), and there are more chars,\n            // we probably need to move past it unless it's a brand new delimiter\n            const delimiterExistedBefore =\n              currentValue[cursorPosition] === formattedValue[cursorPosition];\n            if (delimiterExistedBefore) {\n              infoRef.current.cursorPosition = cursorPosition + 1;\n            }\n          }\n        }\n      }\n\n      onChange?.({ name, value: formattedValue, rawValue });\n      setInternalValue(formattedValue);\n    },\n    [pattern, onChange, internalValue],\n  );\n\n  const handleKeyDown = useCallback((event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.currentTarget && inputRef.current !== event.currentTarget) {\n      inputRef.current = event.currentTarget;\n    }\n  }, []);\n\n  return {\n    formattedValue: internalValue,\n    handleChange,\n    handleKeyDown,\n    maxLength,\n  };\n};\n"],"names":["format","value","pattern","result","valueIndex","i","length","patternChar","stripPatternCharacters","replace","isUserCharacter","character","test","useFormattedInput","_ref","onChange","userValue","_ref$defaultValue","defaultValue","initialValue","useMemo","_useState","useState","_useState2","_slicedToArray","internalValue","setInternalValue","inputRef","useRef","infoRef","maxLength","useEffect","undefined","emptyFormatted","rawValue","newFormatted","_infoRef$current","current","cursorPosition","endOfSection","setSelectionRange","handleChange","useCallback","_ref2","_inputRef$current$sel","_inputRef$current","name","inputValue","cleanValue","currentValue","newInputValue","selectionStart","didDelete","_currentValue$cursorP","deletedChar","deletedDelimiter","beforeCursor","substring","afterCursor","rawBefore","rawAfter","slice","formattedValue","nextChar","nextIsDelimiter","remainingText","nextUserCharIndex","search","hasMoreUserChars","_formattedValue","prevChar","prevIsDelimiter","delimiterExistedBefore","handleKeyDown","event","currentTarget"],"mappings":"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"}