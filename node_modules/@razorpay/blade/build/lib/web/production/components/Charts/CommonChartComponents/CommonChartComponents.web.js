import _defineProperty from '@babel/runtime/helpers/defineProperty';
import 'react';
import { XAxis, YAxis, CartesianGrid, Tooltip, Legend, ReferenceLine } from 'recharts';
import '../utils/index.js';
import { X_OFFSET, Y_OFFSET, X_AXIS_TEXT_BASELINE, componentId, TEXT_BASELINE, PADDING_HORIZONTAL, PADDING_VERTICAL, RECT_HEIGHT } from './tokens.js';
import { calculateTextWidth } from './utils.js';
import { useCommonChartComponentsContext } from './CommonChartComponentsContext.js';
import '../../Typography/index.js';
import '../../Box/index.js';
import '../../BladeProvider/index.js';
import '../../../utils/assignWithoutSideEffects/index.js';
import getIn from '../../../utils/lodashButBetter/get.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { sanitizeString } from '../utils/sanitizeString/sanitizeString.js';
import { isSequentialColor } from '../utils/isSequentialColor.js';
import { getHighestColorInRange } from '../utils/getHighestColorInRange.js';
import { totalChartColors } from '../utils/tokens.js';
import useTheme from '../../BladeProvider/useTheme.js';
import { Box } from '../../Box/Box.js';
import { Text } from '../../Typography/Text/Text.js';
import { Heading } from '../../Typography/Heading/Heading.js';
import { assignWithoutSideEffects } from '../../../utils/assignWithoutSideEffects/assignWithoutSideEffects.js';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var getChartColor = function getChartColor(dataKey, name, dataColorMapping, chartName) {
  var colorKey = chartName === 'donut' ? sanitizeString(name !== null && name !== void 0 ? name : '') : dataKey;
  var mappedColorData = dataColorMapping === null || dataColorMapping === void 0 ? void 0 : dataColorMapping[colorKey !== null && colorKey !== void 0 ? colorKey : ''];
  var mappedColor = mappedColorData.colorToken;
  var isCustomColor = mappedColorData.isCustomColor;
  if ((chartName === 'line' || chartName === 'area') && !isCustomColor) {
    return mappedColor;
  }
  if (mappedColor && isSequentialColor(mappedColor)) {
    return mappedColor !== null && mappedColor !== void 0 ? mappedColor : 'data.background.categorical.azure.faint';
  }
  return getHighestColorInRange({
    colorToken: mappedColor !== null && mappedColor !== void 0 ? mappedColor : 'data.background.categorical.azure.faint',
    followIntensityMapping: chartName === 'donut' && (isCustomColor || Object.keys(dataColorMapping).length > totalChartColors)
  });
};
var ChartXAxis = function ChartXAxis(props) {
  var _useTheme = useTheme(),
    theme = _useTheme.theme;
  return /*#__PURE__*/jsx(XAxis, _objectSpread(_objectSpread({}, props), {}, {
    tick: {
      fill: theme.colors.surface.text.gray.muted,
      fontSize: theme.typography.fonts.size[75],
      fontFamily: theme.typography.fonts.family.text,
      fontWeight: theme.typography.fonts.weight.regular,
      letterSpacing: theme.typography.letterSpacings[100]
    },
    tickLine: false,
    stroke: theme.colors.surface.border.gray.muted,
    label: function label(_ref) {
      var viewBox = _ref.viewBox;
      return /*#__PURE__*/jsx("text", {
        x: viewBox.x + viewBox.width / 2 - X_OFFSET,
        y: viewBox.y + Y_OFFSET + X_AXIS_TEXT_BASELINE,
        textAnchor: "middle",
        fill: theme.colors.surface.text.gray.muted,
        fontSize: theme.typography.fonts.size[75],
        fontFamily: theme.typography.fonts.family.text,
        fontWeight: theme.typography.fonts.weight.regular,
        letterSpacing: theme.typography.letterSpacings[100],
        children: props === null || props === void 0 ? void 0 : props.label
      });
    },
    dataKey: props === null || props === void 0 ? void 0 : props.dataKey
  }));
};
var ChartYAxis = function ChartYAxis(props) {
  var _useTheme2 = useTheme(),
    theme = _useTheme2.theme;
  return /*#__PURE__*/jsx(YAxis, _objectSpread(_objectSpread({}, props), {}, {
    tick: {
      fill: theme.colors.surface.text.gray.muted,
      fontSize: theme.typography.fonts.size[75],
      fontFamily: theme.typography.fonts.family.text,
      fontWeight: theme.typography.fonts.weight.regular,
      letterSpacing: theme.typography.letterSpacings[100]
    },
    tickLine: false,
    stroke: theme.colors.surface.border.gray.muted,
    label: {
      value: props === null || props === void 0 ? void 0 : props.label,
      position: 'insideLeft',
      style: {
        textAnchor: 'middle',
        fill: theme.colors.surface.text.gray.muted,
        fontSize: theme.typography.fonts.size[75],
        fontWeight: theme.typography.fonts.weight.regular,
        fontFamily: theme.typography.fonts.family.text,
        letterSpacing: theme.typography.letterSpacings[100],
        lineHeight: theme.typography.lineHeights[500]
      },
      angle: -90,
      fill: theme.colors.surface.text.gray.subtle
    },
    dataKey: props === null || props === void 0 ? void 0 : props.dataKey
  }));
};
var ChartCartesianGrid = function ChartCartesianGrid(props) {
  var _useTheme3 = useTheme(),
    theme = _useTheme3.theme;
  return /*#__PURE__*/jsx(CartesianGrid, _objectSpread({
    stroke: theme.colors.surface.border.gray.muted,
    vertical: false
  }, props));
};
var CustomTooltip = function CustomTooltip(_ref2) {
  var item = _ref2.item,
    key = _ref2.key;
  var _useTheme4 = useTheme(),
    theme = _useTheme4.theme;
  var _useCommonChartCompon = useCommonChartComponentsContext(),
    dataColorMapping = _useCommonChartCompon.dataColorMapping,
    chartName = _useCommonChartCompon.chartName;
  var toolTipColor = getChartColor(item.dataKey, item.name, dataColorMapping !== null && dataColorMapping !== void 0 ? dataColorMapping : {}, chartName);
  return /*#__PURE__*/jsxs(Box, {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: "spacing.4",
    children: [/*#__PURE__*/jsxs(Box, {
      display: "flex",
      gap: "spacing.3",
      alignItems: "center",
      justifyContent: "center",
      children: [/*#__PURE__*/jsx("div", {
        style: {
          width: theme.spacing[4],
          height: theme.spacing[4],
          backgroundColor: getIn(theme.colors, toolTipColor),
          borderRadius: theme.border.radius.small
        }
      }), /*#__PURE__*/jsx(Text, {
        size: "small",
        weight: "regular",
        color: "surface.text.staticWhite.normal",
        children: item.name
      })]
    }), /*#__PURE__*/jsx(Text, {
      size: "small",
      weight: "regular",
      color: "surface.text.staticWhite.normal",
      children: item.value
    })]
  }, key);
};
var ChartTooltip = function ChartTooltip(props) {
  var _useTheme5 = useTheme(),
    theme = _useTheme5.theme;
  return /*#__PURE__*/jsx(Tooltip, _objectSpread({
    content: function content(_ref3) {
      var payload = _ref3.payload,
        label = _ref3.label;
      var filteredPayLoad = payload.filter(function (item) {
        return item.type !== 'none';
      });
      return /*#__PURE__*/jsxs("div", {
        style: {
          backgroundColor: theme.colors.surface.icon.staticBlack.normal,
          borderRadius: theme.border.radius.large,
          border: "1px solid ".concat(theme.colors.surface.border.gray.muted),
          padding: theme.spacing[4]
        },
        children: [/*#__PURE__*/jsx(Heading, {
          size: "small",
          weight: "semibold",
          color: "surface.text.staticWhite.normal",
          children: label
        }), /*#__PURE__*/jsx(Box, {
          paddingTop: label ? 'spacing.4' : undefined,
          children: filteredPayLoad.map(function (item) {
            return /*#__PURE__*/jsx(CustomTooltip, {
              item: item
            }, item.name);
          })
        })]
      });
    },
    cursor: {
      fill: 'transparent',
      stroke: 'transparent'
    }
  }, props));
};
var LegendItem = function LegendItem(_ref4) {
  var entry = _ref4.entry,
    index = _ref4.index;
  var _useTheme6 = useTheme(),
    theme = _useTheme6.theme;
  var _useCommonChartCompon2 = useCommonChartComponentsContext(),
    dataColorMapping = _useCommonChartCompon2.dataColorMapping,
    chartName = _useCommonChartCompon2.chartName;
  var legendColor = getChartColor(entry.dataKey, entry.value, dataColorMapping !== null && dataColorMapping !== void 0 ? dataColorMapping : {}, chartName);
  return /*#__PURE__*/jsx(Box, {
    display: "flex",
    alignItems: "center",
    children: /*#__PURE__*/jsxs(Box, {
      display: "flex",
      gap: "spacing.3",
      justifyContent: "center",
      alignItems: "center",
      children: [/*#__PURE__*/jsx("span", {
        style: {
          backgroundColor: getIn(theme.colors, legendColor),
          // Uses the color of the line/bar
          width: theme.spacing[4],
          // Size of the square
          height: theme.spacing[4],
          // Size of the square
          display: 'inline-block',
          borderRadius: theme.border.radius.small
        }
      }), /*#__PURE__*/jsx(Text, {
        size: "medium",
        color: "surface.text.gray.muted",
        children: entry.value
      })]
    })
  }, "item-".concat(index));
};
var CustomSquareLegend = function CustomSquareLegend(props) {
  var payload = props.payload,
    layout = props.layout;
  if (!payload || payload.length === 0) {
    return null;
  }

  /*
  This is a custom legend component that is used to display the legend for the chart.
  we need to show the legend only if the legendType is not none. (for example in line chart we don't want to show the legend for the reference line)
  so we are filtering the payload and then mapping over it to display the legend.
  */
  var filteredPayload = payload.filter(function (entry) {
    var _entry$payload;
    return (entry === null || entry === void 0 || (_entry$payload = entry.payload) === null || _entry$payload === void 0 ? void 0 : _entry$payload.legendType) !== 'none' && (entry === null || entry === void 0 ? void 0 : entry.type) !== 'none';
  });
  var isVerticalLayout = layout === 'vertical';
  return /*#__PURE__*/jsx(Box, {
    display: "flex",
    justifyContent: "center",
    gap: "spacing.5",
    flexDirection: isVerticalLayout ? 'column' : 'row',
    width: isVerticalLayout ? '100%' : 'auto',
    flexWrap: "wrap",
    children: filteredPayload.map(function (entry, index) {
      return /*#__PURE__*/jsx(LegendItem, {
        entry: entry,
        index: index
      }, "item-".concat(index));
    })
  });
};
var _ChartLegend = function _ChartLegend(props) {
  var _props$layout;
  var _useTheme7 = useTheme(),
    theme = _useTheme7.theme;
  return /*#__PURE__*/jsx(Legend, _objectSpread({
    wrapperStyle: {
      fontFamily: theme.typography.fonts.family.text,
      fontSize: theme.typography.fonts.size[100],
      color: theme.colors.surface.text.gray.normal,
      paddingTop: theme.spacing[7]
    },
    align: "center",
    verticalAlign: props.layout === 'vertical' ? 'middle' : 'bottom',
    content: /*#__PURE__*/jsx(CustomSquareLegend, {
      layout: (_props$layout = props.layout) !== null && _props$layout !== void 0 ? _props$layout : 'horizontal'
    })
  }, props));
};
var ChartLegend = /*#__PURE__*/assignWithoutSideEffects(_ChartLegend, {
  componentId: componentId.chartLegend
});
var CustomReferenceLabel = function CustomReferenceLabel(_ref5) {
  var viewBox = _ref5.viewBox,
    value = _ref5.value,
    isVertical = _ref5.isVertical;
  // Extract viewBox coordinates with fallback values to prevent undefined errors.
  // viewBox contains the positioning information for the reference line label from Recharts.
  var _ref6 = viewBox !== null && viewBox !== void 0 ? viewBox : {
      x: 0,
      y: 0,
      width: 0
    },
    x = _ref6.x,
    y = _ref6.y,
    width = _ref6.width;
  var _useTheme8 = useTheme(),
    theme = _useTheme8.theme;

  // Calculate dynamic text width to ensure the background rectangle fits the text perfectly.
  // This prevents text overflow for long labels and avoids unnecessarily large rectangles for short text.
  // The function also handles text truncation with ellipsis if the text exceeds the maximum width.
  var _ref7 = value ? calculateTextWidth(value, theme) : {
      width: 80,
      displayText: value !== null && value !== void 0 ? value : ''
    },
    RECT_WIDTH = _ref7.width,
    displayText = _ref7.displayText;
  var rect_x = isVertical ? x + width - RECT_WIDTH / 2 : x + width - RECT_WIDTH;
  var rect_y = isVertical ? y : y - TEXT_BASELINE;
  // Text position with padding inside the rectangle
  var text_x = rect_x + PADDING_HORIZONTAL + (RECT_WIDTH - PADDING_HORIZONTAL * 2) / 2;
  var text_y = rect_y + PADDING_VERTICAL + TEXT_BASELINE; // +15 for text baseline

  return /*#__PURE__*/jsxs("g", {
    children: [/*#__PURE__*/jsx("rect", {
      x: rect_x,
      y: rect_y,
      width: RECT_WIDTH,
      height: RECT_HEIGHT,
      rx: theme.border.radius.medium,
      fill: theme.colors.surface.background.gray.subtle,
      stroke: theme.colors.surface.border.gray.muted,
      strokeWidth: "1"
    }), /*#__PURE__*/jsx("text", {
      x: text_x,
      y: text_y,
      textAnchor: "middle",
      fill: theme.colors.surface.text.gray.normal,
      fontSize: theme.typography.fonts.size[50],
      fontFamily: theme.typography.fonts.family.text,
      fontWeight: theme.typography.fonts.weight.medium,
      letterSpacing: theme.typography.letterSpacings[100],
      children: displayText
    })]
  });
};
var ChartReferenceLine = function ChartReferenceLine(_ref8) {
  var label = _ref8.label,
    x = _ref8.x,
    y = _ref8.y;
  var _useTheme9 = useTheme(),
    theme = _useTheme9.theme;
  return /*#__PURE__*/jsx(ReferenceLine, {
    stroke: theme.colors.data.background.categorical.gray.intense,
    strokeWidth: 2,
    strokeDasharray: "4 4",
    label: /*#__PURE__*/jsx(CustomReferenceLabel, {
      value: label,
      isVertical: Boolean(x)
    }),
    x: x,
    y: y
  });
};

export { ChartCartesianGrid, ChartLegend, ChartReferenceLine, ChartTooltip, ChartXAxis, ChartYAxis };
//# sourceMappingURL=CommonChartComponents.web.js.map
