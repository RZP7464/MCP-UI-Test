import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import React__default, { createElement, useState } from 'react';
import { Bar, ResponsiveContainer, BarChart } from 'recharts';
import '../utils/index.js';
import '../CommonChartComponents/index.js';
import { useBarChartContext, BarChartContext } from './BarChartContext.js';
import { DISTANCE_BETWEEN_STACKED_BARS, componentIds, BAR_SIZE, DISTANCE_BETWEEN_BARS, DISTANCE_BETWEEN_CATEGORY_BARS } from './tokens.js';
import '../../BladeProvider/index.js';
import '../../Box/BaseBox/index.js';
import '../../../utils/metaAttribute/index.js';
import getIn from '../../../utils/lodashButBetter/get.js';
import isNumber from '../../../utils/lodashButBetter/isNumber.js';
import '../../../utils/assignWithoutSideEffects/index.js';
import '../../../utils/isValidAllowedChildren/index.js';
import '../../../utils/makeAnalyticsAttribute/index.js';
import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import useTheme from '../../BladeProvider/useTheme.js';
import useChartsColorTheme from '../utils/useColorTheme.js';
import { getHighestColorInRange } from '../utils/getHighestColorInRange.js';
import { assignWithoutSideEffects } from '../../../utils/assignWithoutSideEffects/assignWithoutSideEffects.js';
import { getComponentId } from '../../../utils/isValidAllowedChildren/isValidAllowedChildren.js';
import { assignDataColorMapping } from '../utils/assignDataColorMapping/assignDataColorMapping.js';
import { CommonChartComponentsContext } from '../CommonChartComponents/CommonChartComponentsContext.js';
import { BaseBox } from '../../Box/BaseBox/BaseBox.web.js';
import { metaAttribute } from '../../../utils/metaAttribute/metaAttribute.web.js';
import { makeAnalyticsAttribute } from '../../../utils/makeAnalyticsAttribute/makeAnalyticsAttribute.js';

var _excluded = ["color", "name", "dataKey", "activeBar", "label", "showLegend", "_index"],
  _excluded2 = ["children", "colorTheme", "layout", "testID", "data"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// Bar component - resolves Blade color tokens to actual colors
var _ChartBar = /*#__PURE__*/React__default.memo(function (_ref) {
  var color = _ref.color,
    name = _ref.name,
    dataKey = _ref.dataKey,
    _ref$activeBar = _ref.activeBar,
    activeBar = _ref$activeBar === void 0 ? false : _ref$activeBar,
    _ref$label = _ref.label,
    label = _ref$label === void 0 ? false : _ref$label,
    _ref$showLegend = _ref.showLegend,
    showLegend = _ref$showLegend === void 0 ? true : _ref$showLegend,
    _ref$_index = _ref._index,
    _index = _ref$_index === void 0 ? 0 : _ref$_index,
    rest = _objectWithoutProperties(_ref, _excluded);
  var _useTheme = useTheme(),
    theme = _useTheme.theme;
  var _useBarChartContext = useBarChartContext(),
    layout = _useBarChartContext.layout,
    activeIndex = _useBarChartContext.activeIndex,
    _colorTheme = _useBarChartContext.colorTheme,
    totalBars = _useBarChartContext.totalBars;
  var defaultColorArray = useChartsColorTheme({
    colorTheme: _colorTheme,
    chartName: 'bar',
    chartDataIndicators: totalBars
  });
  var fill = getIn(theme.colors, color !== null && color !== void 0 ? color : defaultColorArray[_index]);
  var strokeFill = getIn(theme.colors, getHighestColorInRange({
    colorToken: color !== null && color !== void 0 ? color : defaultColorArray[_index],
    followIntensityMapping: Boolean(color)
  }));
  var isStacked = rest.stackId !== undefined;
  var animationBegin = isStacked ? theme.motion.duration.gentle / totalBars * _index : theme.motion.duration.gentle;
  var animationDuration = isStacked ? theme.motion.duration.gentle / totalBars : theme.motion.duration.gentle;
  return /*#__PURE__*/createElement(Bar, _objectSpread(_objectSpread({}, rest), {}, {
    fill: fill,
    legendType: showLegend ? 'rect' : 'none',
    activeBar: activeBar,
    label: label,
    animationBegin: animationBegin,
    animationDuration: animationDuration,
    animationEasing: "linear",
    dataKey: dataKey,
    name: name,
    key: "".concat(dataKey, "-").concat(_index, "-").concat(name),
    shape: function shape(props) {
      var _ref2 = props,
        fill = _ref2.fill,
        x = _ref2.x,
        y = _ref2.y,
        width = _ref2.width,
        height = _ref2.height,
        barIndex = _ref2.index;
      var fillOpacity = isNumber(activeIndex) ? barIndex === activeIndex ? 1 : 0.2 : 1;
      var gap = DISTANCE_BETWEEN_STACKED_BARS;
      var isVertical = layout === 'vertical';
      if (isVertical) {
        return /*#__PURE__*/jsxs(Fragment, {
          children: [/*#__PURE__*/jsx("rect", {
            fill: fill,
            x: x + gap / 1.5,
            y: y,
            width: width - gap,
            height: height,
            fillOpacity: fillOpacity
          }), /*#__PURE__*/jsx("rect", {
            fill: strokeFill,
            x: x + gap / 1.5 + (width - gap) - 1.5 // Position at the right end
            ,
            y: y,
            width: width > gap ? 1.5 : 0,
            height: height,
            fillOpacity: fillOpacity
          })]
        });
      }
      return /*#__PURE__*/jsxs(Fragment, {
        children: [/*#__PURE__*/jsx("rect", {
          fill: fill,
          x: x,
          y: y + gap / 1.5,
          width: width,
          height: height > gap ? height - gap : 0,
          fillOpacity: fillOpacity
        }), /*#__PURE__*/jsx("rect", {
          fill: strokeFill,
          x: x,
          y: y + gap / 1.5,
          width: width,
          height: height > gap ? 1.5 : 0,
          fillOpacity: fillOpacity
        })]
      });
    }
  }));
});
var ChartBar = /*#__PURE__*/assignWithoutSideEffects(_ChartBar, {
  componentId: componentIds.chartBar
});

// BarChart wrapper with default margin, auto-color assignment, and max bars guard
var ChartBarWrapper = function ChartBarWrapper(_ref3) {
  var children = _ref3.children,
    _ref3$colorTheme = _ref3.colorTheme,
    colorTheme = _ref3$colorTheme === void 0 ? 'categorical' : _ref3$colorTheme,
    _ref3$layout = _ref3.layout,
    layout = _ref3$layout === void 0 ? 'horizontal' : _ref3$layout,
    testID = _ref3.testID,
    _ref3$data = _ref3.data,
    data = _ref3$data === void 0 ? [] : _ref3$data,
    restProps = _objectWithoutProperties(_ref3, _excluded2);
  var _useState = useState(undefined),
    _useState2 = _slicedToArray(_useState, 2),
    activeIndex = _useState2[0],
    setActiveIndex = _useState2[1];
  var themeColors = useChartsColorTheme({
    colorTheme: colorTheme,
    chartName: 'bar'
  });
  var _React$useMemo = React__default.useMemo(function () {
      var childrenArray = React__default.Children.toArray(children);
      var dataColorMapping = {};

      // Count ChartBar components
      var totalBars = childrenArray.filter(function (child) {
        return /*#__PURE__*/React__default.isValidElement(child) && getComponentId(child) === componentIds.chartBar;
      }).length;
      var BarChartIndex = 0;
      /**
       * We check to check child of ChartBarWrapper. if they have any custom color we store that.
       * We need these mapping because colors of tooltip & legend is determine based on this
       *  recharts do provide a color but it is hex code and we need blade color token .
       */
      var modifiedChildren = React__default.Children.map(children, function (child) {
        if (/*#__PURE__*/React__default.isValidElement(child) && getComponentId(child) === componentIds.chartBar) {
          var _child$props, _child$props2;
          var childColor = child === null || child === void 0 || (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.color;
          var dataKey = child === null || child === void 0 || (_child$props2 = child.props) === null || _child$props2 === void 0 ? void 0 : _child$props2.dataKey;
          if (dataKey) {
            //  assign  colors to the dataColorMapping, if no color is assigned  we assign color in `assignDataColorMapping`
            dataColorMapping[dataKey] = {
              colorToken: childColor,
              isCustomColor: Boolean(childColor)
            };
          }
          return /*#__PURE__*/React__default.cloneElement(child, {
            _index: BarChartIndex++
          });
        }
        return child;
      });
      assignDataColorMapping(dataColorMapping, themeColors);
      return {
        barChartModifiedChildrens: modifiedChildren,
        totalBars: totalBars,
        dataColorMapping: dataColorMapping
      };
    }, [children, themeColors]),
    barChartModifiedChildrens = _React$useMemo.barChartModifiedChildrens,
    totalBars = _React$useMemo.totalBars,
    dataColorMapping = _React$useMemo.dataColorMapping;
  return /*#__PURE__*/jsx(CommonChartComponentsContext.Provider, {
    value: {
      chartName: 'bar',
      dataColorMapping: dataColorMapping
    },
    children: /*#__PURE__*/jsx(BaseBox, _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, metaAttribute({
      name: 'bar-chart',
      testID: testID
    })), makeAnalyticsAttribute(restProps)), {}, {
      width: "100%",
      height: "100%"
    }, restProps), {}, {
      children: /*#__PURE__*/jsx(BarChartContext.Provider, {
        value: {
          layout: layout,
          activeIndex: activeIndex,
          colorTheme: colorTheme,
          totalBars: totalBars
        },
        children: /*#__PURE__*/jsx(ResponsiveContainer, {
          width: "100%",
          height: "100%",
          children: /*#__PURE__*/jsx(BarChart, {
            barSize: BAR_SIZE,
            barGap: DISTANCE_BETWEEN_BARS,
            barCategoryGap: DISTANCE_BETWEEN_CATEGORY_BARS,
            onMouseMove: function onMouseMove(state) {
              setActiveIndex(state !== null && state !== void 0 && state.activeIndex ? Number(state === null || state === void 0 ? void 0 : state.activeIndex) : undefined);
            },
            onMouseLeave: function onMouseLeave() {
              setActiveIndex(undefined);
            },
            layout: layout,
            data: data,
            children: barChartModifiedChildrens
          })
        })
      })
    }))
  });
};

export { ChartBar, ChartBarWrapper };
//# sourceMappingURL=BarChart.web.js.map
