{"version":3,"file":"useFormattedInput.js","sources":["../../../../../../src/components/Input/TextInput/useFormattedInput.ts"],"sourcesContent":["import type React from 'react';\nimport { useCallback, useRef, useState, useEffect, useMemo } from 'react';\nimport type { FormInputOnEvent } from '~components/Form/FormTypes';\n\n/**\n * Formats user input according to pattern. format(\"1234\", \"##/##\") → \"12/34\"\n */\nconst format = (value: string, pattern: string): string => {\n  if (!pattern) return value;\n\n  let result = '';\n  let valueIndex = 0;\n\n  for (let i = 0; i < pattern.length; i++) {\n    const patternChar = pattern[i]; // \"#\" or \"/\"\n\n    if (patternChar === '#') {\n      if (valueIndex < value.length) {\n        result += value[valueIndex]; // add \"1\" from \"1234\"\n        valueIndex++;\n      } else {\n        break; // No more input chars, stop\n      }\n    } else {\n      result += patternChar; // add \"/\" delimiter\n    }\n  }\n\n  return result; // \"12/34\"\n};\n\n/**\n * Removes delimiters, keeps only user input. stripPatternCharacters(\"12/34\") → \"1234\"\n */\nconst stripPatternCharacters = (value: string): string => {\n  return value.replace(/[^\\dA-z]/g, ''); // \"12/34\" → \"1234\" (removes \"/\")\n};\n\n/**\n * Checks if character is user input vs delimiter. isUserCharacter('1') → true, isUserCharacter('/') → false\n */\nconst isUserCharacter = (character: string): boolean => {\n  return /[\\dA-z]/.test(character); // \"1\" → true, \"/\" → false\n};\n\ntype UseFormattedInputProps = {\n  format?: string;\n  onChange?: (params: { name?: string; value?: string; rawValue?: string }) => void;\n  value?: string;\n  defaultValue?: string;\n};\n\ntype UseFormattedInputReturn = {\n  formattedValue: string;\n  handleChange: FormInputOnEvent;\n  handleKeyDown: (event: React.KeyboardEvent<HTMLInputElement>) => void;\n  maxLength?: number;\n};\n\n/**\n * Hook for pattern-based input formatting with smart cursor positioning.\n * useFormattedInput({ format: \"##/##\" }) transforms \"1234\" → \"12/34\"\n */\nexport const useFormattedInput = ({\n  format: pattern,\n  onChange,\n  value: userValue,\n  defaultValue = '',\n}: UseFormattedInputProps): UseFormattedInputReturn => {\n  const initialValue = useMemo(() => {\n    return format(userValue ?? defaultValue, pattern ?? '');\n  }, [userValue, defaultValue, pattern]);\n\n  const [internalValue, setInternalValue] = useState(initialValue);\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const infoRef = useRef<{\n    cursorPosition?: number;\n    endOfSection?: boolean;\n  }>({});\n\n  const maxLength = useMemo(() => pattern?.length, [pattern]);\n\n  // Reset internal state when parent clears value (form resets, external state changes)\n  // Preserves format delimiters for visual guidance. Example: \"(###)\" → \"(   )\" when cleared\n  useEffect(() => {\n    if ((userValue === '' || userValue === undefined) && defaultValue === '') {\n      const emptyFormatted = format('', pattern ?? '');\n      setInternalValue(emptyFormatted);\n    }\n    // DATEPICKER FIX: Sync internal state when external value changes\n    // This addresses the issue where DatePicker programmatically updates the value prop\n    // (e.g., when user selects date from calendar), but the formatted input's internal\n    // state doesn't update, causing the input to not reflect the new value.\n    // Without this, only user typing and empty resets were handled.\n    if (userValue !== undefined && userValue !== '' && pattern) {\n      const rawValue = stripPatternCharacters(userValue);\n      const newFormatted = format(rawValue, pattern);\n\n      // Only update if the formatted value actually changed to avoid unnecessary re-renders\n      if (newFormatted !== internalValue) {\n        setInternalValue(newFormatted);\n      }\n    }\n  }, [userValue, pattern]);\n\n  // Apply calculated cursor position after value updates\n  useEffect(() => {\n    const { cursorPosition, endOfSection } = infoRef.current;\n\n    if (endOfSection || cursorPosition === undefined) return; // Skip if no position or end section\n\n    if (inputRef.current) {\n      inputRef.current.setSelectionRange(cursorPosition, cursorPosition);\n    }\n  }, [internalValue]);\n\n  const handleChange: FormInputOnEvent = useCallback(\n    ({ name, value: inputValue }) => {\n      if (!pattern) {\n        // No pattern = regular input\n        const cleanValue = inputValue ?? '';\n        onChange?.({ name, value: cleanValue });\n        setInternalValue(cleanValue);\n        return;\n      }\n\n      const currentValue = internalValue; // \"12/34\" (user wants to delete \"/\")\n      const newInputValue = inputValue ?? ''; // \"1234\" (after deleting \"/\")\n      const cursorPosition = inputRef.current?.selectionStart ?? 0; // 2 (cursor where \"/\" was)\n      const didDelete = newInputValue.length < currentValue.length; // 4 < 5 → true\n\n      infoRef.current.cursorPosition = cursorPosition;\n\n      let rawValue = stripPatternCharacters(newInputValue); // \"1234\" → \"1234\"\n\n      // Handle special case: user deleted a delimiter (like deleting \"/\" in \"12/|34\")\n      if (didDelete) {\n        const deletedChar = currentValue[cursorPosition] ?? ''; // \"12/34\"[2] → \"/\"\n        const deletedDelimiter = !isUserCharacter(deletedChar); // \"/\" → true (is delimiter)\n\n        if (deletedDelimiter) {\n          // true (will execute for \"/\" deletion)\n          const beforeCursor = newInputValue.substring(0, cursorPosition); // \"12\" (before cursor)\n          const afterCursor = newInputValue.substring(cursorPosition); // \"34\" (after cursor)\n          const rawBefore = stripPatternCharacters(beforeCursor); // \"12\" → \"12\"\n          const rawAfter = stripPatternCharacters(afterCursor); // \"34\" → \"34\"\n\n          rawValue = rawBefore.slice(0, -1) + rawAfter; // \"12\".slice(0,-1) + \"34\" → \"1\" + \"34\" → \"134\"\n\n          // Removes trailing non-alphanumeric characters from the end of the string, preserving the last alphanumeric word before them.\n          infoRef.current.cursorPosition =\n            beforeCursor.replace(/([\\d\\w]+)[^\\dA-z]+$/, '$1').length - 1;\n        }\n      }\n\n      const formattedValue = format(rawValue, pattern); // format(\"134\", \"##/##\") → \"13/4\"\n      infoRef.current.endOfSection = false;\n\n      // Handle cursor positioning when typing (not deleting)\n      if (!didDelete) {\n        // User types \"2\" in \"1|\" → becomes \"12|/\" → should jump to \"12/|\"\n        const nextChar = formattedValue[cursorPosition]; // \"12/\"[2] → \"/\" (delimiter)\n        const nextIsDelimiter = nextChar ? !isUserCharacter(nextChar) : false; // \"/\" → true\n\n        const remainingText = formattedValue.substring(cursorPosition); // \"12/\".substring(2) → \"/\"\n        const nextUserCharIndex = remainingText.search(/[\\dA-z]/); // \"/\".search() → -1 (no user chars)\n        const hasMoreUserChars = nextUserCharIndex !== -1; // -1 !== -1 → false\n\n        infoRef.current.endOfSection = nextIsDelimiter && !hasMoreUserChars; // true && false → false\n\n        // Move cursor past auto-inserted delimiters for smooth typing\n        if (nextIsDelimiter && hasMoreUserChars) {\n          const prevChar = formattedValue[cursorPosition - 1] ?? '';\n          const prevIsDelimiter = !isUserCharacter(prevChar);\n\n          if (prevIsDelimiter) {\n            infoRef.current.cursorPosition = cursorPosition + nextUserCharIndex + 1;\n          } else {\n            // If we're at a delimiter after typing (not deleting), and there are more chars,\n            // we probably need to move past it unless it's a brand new delimiter\n            const delimiterExistedBefore =\n              currentValue[cursorPosition] === formattedValue[cursorPosition];\n            if (delimiterExistedBefore) {\n              infoRef.current.cursorPosition = cursorPosition + 1;\n            }\n          }\n        }\n      }\n\n      onChange?.({ name, value: formattedValue, rawValue });\n      setInternalValue(formattedValue);\n    },\n    [pattern, onChange, internalValue],\n  );\n\n  const handleKeyDown = useCallback((event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.currentTarget && inputRef.current !== event.currentTarget) {\n      inputRef.current = event.currentTarget;\n    }\n  }, []);\n\n  return {\n    formattedValue: internalValue,\n    handleChange,\n    handleKeyDown,\n    maxLength,\n  };\n};\n"],"names":["format","value","pattern","result","valueIndex","i","length","patternChar","stripPatternCharacters","replace","isUserCharacter","character","test","useFormattedInput","_ref","onChange","userValue","_ref$defaultValue","defaultValue","initialValue","useMemo","_useState","useState","_useState2","_slicedToArray","internalValue","setInternalValue","inputRef","useRef","infoRef","maxLength","useEffect","undefined","emptyFormatted","rawValue","newFormatted","_infoRef$current","current","cursorPosition","endOfSection","setSelectionRange","handleChange","useCallback","_ref2","_inputRef$current$sel","_inputRef$current","name","inputValue","cleanValue","currentValue","newInputValue","selectionStart","didDelete","_currentValue$cursorP","deletedChar","deletedDelimiter","beforeCursor","substring","afterCursor","rawBefore","rawAfter","slice","formattedValue","nextChar","nextIsDelimiter","remainingText","nextUserCharIndex","search","hasMoreUserChars","_formattedValue","prevChar","prevIsDelimiter","delimiterExistedBefore","handleKeyDown","event","currentTarget"],"mappings":";;;AAOA,IAAMA,MAAM,CAAG,SAATA,MAAMA,CAAIC,KAAa,CAAEC,OAAe,CAAa,CACzD,GAAI,CAACA,OAAO,CAAE,OAAOD,KAAK,CAE1B,IAAIE,MAAM,CAAG,EAAE,CACf,IAAIC,UAAU,CAAG,CAAC,CAElB,IAAK,IAAIC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGH,OAAO,CAACI,MAAM,CAAED,CAAC,EAAE,CAAE,CACvC,IAAME,WAAW,CAAGL,OAAO,CAACG,CAAC,CAAC,CAE9B,GAAIE,WAAW,GAAK,GAAG,CAAE,CACvB,GAAIH,UAAU,CAAGH,KAAK,CAACK,MAAM,CAAE,CAC7BH,MAAM,EAAIF,KAAK,CAACG,UAAU,CAAC,CAC3BA,UAAU,EAAE,CACd,CAAC,KAAM,CACL,MACF,CACF,CAAC,KAAM,CACLD,MAAM,EAAII,WAAW,CACvB,CACF,CAEA,OAAOJ,MAAM,CACf,CAAC,CAKD,IAAMK,sBAAsB,CAAG,SAAzBA,sBAAsBA,CAAIP,KAAa,CAAa,CACxD,OAAOA,KAAK,CAACQ,OAAO,CAAC,WAAW,CAAE,EAAE,CAAC,CACvC,CAAC,CAKD,IAAMC,eAAe,CAAG,SAAlBA,eAAeA,CAAIC,SAAiB,CAAc,CACtD,OAAgB,SAAA,CAACC,IAAI,CAACD,SAAS,CAAC,CAClC,CAAC,CAoBY,IAAAE,iBAAiB,CAAG,SAApBA,iBAAiBA,CAAAC,IAAA,CAKyB,CAAA,IAJ7CZ,OAAO,CAAAY,IAAA,CAAfd,MAAM,CACNe,QAAQ,CAAAD,IAAA,CAARC,QAAQ,CACDC,SAAS,CAAAF,IAAA,CAAhBb,KAAK,CAAAgB,iBAAA,CAAAH,IAAA,CACLI,YAAY,CAAZA,YAAY,CAAAD,iBAAA,GAAG,KAAA,CAAA,CAAA,EAAE,CAAAA,iBAAA,CAEjB,IAAME,YAAY,CAAGC,OAAO,CAAC,UAAM,CACjC,OAAOpB,MAAM,CAACgB,SAAS,EAAA,IAAA,CAATA,SAAS,CAAIE,YAAY,CAAEhB,OAAO,EAAPA,IAAAA,CAAAA,OAAO,CAAI,EAAE,CAAC,CACzD,CAAC,CAAE,CAACc,SAAS,CAAEE,YAAY,CAAEhB,OAAO,CAAC,CAAC,CAEtC,IAAAmB,SAAA,CAA0CC,QAAQ,CAACH,YAAY,CAAC,CAAAI,UAAA,CAAAC,cAAA,CAAAH,SAAA,CAAzDI,CAAAA,CAAAA,CAAAA,aAAa,CAAAF,UAAA,CAAEG,CAAAA,CAAAA,CAAAA,gBAAgB,CAAAH,UAAA,CACtC,CAAA,CAAA,CAAA,IAAMI,QAAQ,CAAGC,MAAM,CAA0B,IAAI,CAAC,CACtD,IAAMC,OAAO,CAAGD,MAAM,CAGnB,EAAE,CAAC,CAEN,IAAME,SAAS,CAAGV,OAAO,CAAC,UAAM,CAAA,OAAAlB,OAAO,EAAA,IAAA,CAAA,KAAA,CAAA,CAAPA,OAAO,CAAEI,MAAM,CAAA,CAAA,CAAE,CAACJ,OAAO,CAAC,CAAC,CAI3D6B,SAAS,CAAC,UAAM,CACd,GAAI,CAACf,SAAS,GAAK,EAAE,EAAIA,SAAS,GAAKgB,SAAS,GAAKd,YAAY,GAAK,EAAE,CAAE,CACxE,IAAMe,cAAc,CAAGjC,MAAM,CAAC,EAAE,CAAEE,OAAO,EAAPA,IAAAA,CAAAA,OAAO,CAAI,EAAE,CAAC,CAChDwB,gBAAgB,CAACO,cAAc,CAAC,CAClC,CAMA,GAAIjB,SAAS,GAAKgB,SAAS,EAAIhB,SAAS,GAAK,EAAE,EAAId,OAAO,CAAE,CAC1D,IAAMgC,QAAQ,CAAG1B,sBAAsB,CAACQ,SAAS,CAAC,CAClD,IAAMmB,YAAY,CAAGnC,MAAM,CAACkC,QAAQ,CAAEhC,OAAO,CAAC,CAG9C,GAAIiC,YAAY,GAAKV,aAAa,CAAE,CAClCC,gBAAgB,CAACS,YAAY,CAAC,CAChC,CACF,CACF,CAAC,CAAE,CAACnB,SAAS,CAAEd,OAAO,CAAC,CAAC,CAGxB6B,SAAS,CAAC,UAAM,CACd,IAAAK,gBAAA,CAAyCP,OAAO,CAACQ,OAAO,CAAhDC,cAAc,CAAAF,gBAAA,CAAdE,cAAc,CAAEC,YAAY,CAAAH,gBAAA,CAAZG,YAAY,CAEpC,GAAIA,YAAY,EAAID,cAAc,GAAKN,SAAS,CAAE,OAElD,GAAIL,QAAQ,CAACU,OAAO,CAAE,CACpBV,QAAQ,CAACU,OAAO,CAACG,iBAAiB,CAACF,cAAc,CAAEA,cAAc,CAAC,CACpE,CACF,CAAC,CAAE,CAACb,aAAa,CAAC,CAAC,CAEnB,IAAMgB,YAA8B,CAAGC,WAAW,CAChD,SAAAC,KAAA,CAAiC,CAAA,IAAAC,qBAAA,CAAAC,iBAAA,CAAA,IAA9BC,IAAI,CAAAH,KAAA,CAAJG,IAAI,CAASC,UAAU,CAAAJ,KAAA,CAAjB1C,KAAK,CACZ,GAAI,CAACC,OAAO,CAAE,CAEZ,IAAM8C,UAAU,CAAGD,UAAU,EAAVA,IAAAA,CAAAA,UAAU,CAAI,EAAE,CACnChC,QAAQ,cAARA,QAAQ,CAAG,CAAE+B,IAAI,CAAJA,IAAI,CAAE7C,KAAK,CAAE+C,UAAW,CAAC,CAAC,CACvCtB,gBAAgB,CAACsB,UAAU,CAAC,CAC5B,OACF,CAEA,IAAMC,YAAY,CAAGxB,aAAa,CAClC,IAAMyB,aAAa,CAAGH,UAAU,EAAA,IAAA,CAAVA,UAAU,CAAI,EAAE,CACtC,IAAMT,cAAc,CAAA,CAAAM,qBAAA,CAAA,CAAAC,iBAAA,CAAGlB,QAAQ,CAACU,OAAO,GAAhBQ,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,iBAAA,CAAkBM,cAAc,GAAAP,IAAAA,CAAAA,qBAAA,CAAI,CAAC,CAC5D,IAAMQ,SAAS,CAAGF,aAAa,CAAC5C,MAAM,CAAG2C,YAAY,CAAC3C,MAAM,CAE5DuB,OAAO,CAACQ,OAAO,CAACC,cAAc,CAAGA,cAAc,CAE/C,IAAIJ,QAAQ,CAAG1B,sBAAsB,CAAC0C,aAAa,CAAC,CAGpD,GAAIE,SAAS,CAAE,CAAA,IAAAC,qBAAA,CACb,IAAMC,WAAW,CAAAD,CAAAA,qBAAA,CAAGJ,YAAY,CAACX,cAAc,CAAC,GAAA,IAAA,CAAAe,qBAAA,CAAI,EAAE,CACtD,IAAME,gBAAgB,CAAG,CAAC7C,eAAe,CAAC4C,WAAW,CAAC,CAEtD,GAAIC,gBAAgB,CAAE,CAEpB,IAAMC,YAAY,CAAGN,aAAa,CAACO,SAAS,CAAC,CAAC,CAAEnB,cAAc,CAAC,CAC/D,IAAMoB,WAAW,CAAGR,aAAa,CAACO,SAAS,CAACnB,cAAc,CAAC,CAC3D,IAAMqB,SAAS,CAAGnD,sBAAsB,CAACgD,YAAY,CAAC,CACtD,IAAMI,QAAQ,CAAGpD,sBAAsB,CAACkD,WAAW,CAAC,CAEpDxB,QAAQ,CAAGyB,SAAS,CAACE,KAAK,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAAGD,QAAQ,CAG5C/B,OAAO,CAACQ,OAAO,CAACC,cAAc,CAC5BkB,YAAY,CAAC/C,OAAO,CAAC,qBAAqB,CAAE,IAAI,CAAC,CAACH,MAAM,CAAG,CAAC,CAChE,CACF,CAEA,IAAMwD,cAAc,CAAG9D,MAAM,CAACkC,QAAQ,CAAEhC,OAAO,CAAC,CAChD2B,OAAO,CAACQ,OAAO,CAACE,YAAY,CAAG,KAAK,CAGpC,GAAI,CAACa,SAAS,CAAE,CAEd,IAAMW,QAAQ,CAAGD,cAAc,CAACxB,cAAc,CAAC,CAC/C,IAAM0B,eAAe,CAAGD,QAAQ,CAAG,CAACrD,eAAe,CAACqD,QAAQ,CAAC,CAAG,KAAK,CAErE,IAAME,aAAa,CAAGH,cAAc,CAACL,SAAS,CAACnB,cAAc,CAAC,CAC9D,IAAM4B,iBAAiB,CAAGD,aAAa,CAACE,MAAM,CAAC,SAAS,CAAC,CACzD,IAAMC,gBAAgB,CAAGF,iBAAiB,GAAK,CAAC,CAAC,CAEjDrC,OAAO,CAACQ,OAAO,CAACE,YAAY,CAAGyB,eAAe,EAAI,CAACI,gBAAgB,CAGnE,GAAIJ,eAAe,EAAII,gBAAgB,CAAE,CAAA,IAAAC,eAAA,CACvC,IAAMC,QAAQ,CAAA,CAAAD,eAAA,CAAGP,cAAc,CAACxB,cAAc,CAAG,CAAC,CAAC,GAAA,IAAA,CAAA+B,eAAA,CAAI,EAAE,CACzD,IAAME,eAAe,CAAG,CAAC7D,eAAe,CAAC4D,QAAQ,CAAC,CAElD,GAAIC,eAAe,CAAE,CACnB1C,OAAO,CAACQ,OAAO,CAACC,cAAc,CAAGA,cAAc,CAAG4B,iBAAiB,CAAG,CAAC,CACzE,CAAC,KAAM,CAGL,IAAMM,sBAAsB,CAC1BvB,YAAY,CAACX,cAAc,CAAC,GAAKwB,cAAc,CAACxB,cAAc,CAAC,CACjE,GAAIkC,sBAAsB,CAAE,CAC1B3C,OAAO,CAACQ,OAAO,CAACC,cAAc,CAAGA,cAAc,CAAG,CAAC,CACrD,CACF,CACF,CACF,CAEAvB,QAAQ,EAARA,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,QAAQ,CAAG,CAAE+B,IAAI,CAAJA,IAAI,CAAE7C,KAAK,CAAE6D,cAAc,CAAE5B,QAAQ,CAARA,QAAS,CAAC,CAAC,CACrDR,gBAAgB,CAACoC,cAAc,CAAC,CAClC,CAAC,CACD,CAAC5D,OAAO,CAAEa,QAAQ,CAAEU,aAAa,CACnC,CAAC,CAED,IAAMgD,aAAa,CAAG/B,WAAW,CAAC,SAACgC,KAA4C,CAAK,CAClF,GAAIA,KAAK,CAACC,aAAa,EAAIhD,QAAQ,CAACU,OAAO,GAAKqC,KAAK,CAACC,aAAa,CAAE,CACnEhD,QAAQ,CAACU,OAAO,CAAGqC,KAAK,CAACC,aAAa,CACxC,CACF,CAAC,CAAE,EAAE,CAAC,CAEN,OAAO,CACLb,cAAc,CAAErC,aAAa,CAC7BgB,YAAY,CAAZA,YAAY,CACZgC,aAAa,CAAbA,aAAa,CACb3C,SAAS,CAATA,SACF,CAAC,CACH;;;;"}