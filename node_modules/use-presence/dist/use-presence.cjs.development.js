'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

/**
 * Animates the appearance of its children.
 */

function usePresence(
/** Indicates whether the component that the resulting values will be used upon should be visible to the user. */
isVisible, opts) {
  var _opts$initialEnter;

  var exitTransitionDuration = 'exitTransitionDuration' in opts ? opts.exitTransitionDuration : opts.transitionDuration;
  var enterTransitionDuration = 'enterTransitionDuration' in opts ? opts.enterTransitionDuration : opts.transitionDuration;
  var initialEnter = (_opts$initialEnter = opts.initialEnter) != null ? _opts$initialEnter : false;

  var _useState = react.useState(initialEnter ? false : isVisible),
      animateIsVisible = _useState[0],
      setAnimateIsVisible = _useState[1];

  var _useState2 = react.useState(isVisible),
      isMounted = _useState2[0],
      setIsMounted = _useState2[1];

  var _useState3 = react.useState(initialEnter ? false : isVisible),
      hasEntered = _useState3[0],
      setHasEntered = _useState3[1];

  var isExiting = isMounted && !isVisible;
  var isEntering = isVisible && !hasEntered;
  var isAnimating = isEntering || isExiting;
  react.useEffect(function () {
    if (isVisible) {
      // `animateVisible` needs to be set to `true` in a second step, as
      // when both flags would be flipped at the same time, there would
      // be no transition. See the second effect below.
      setIsMounted(true);
    } else {
      setHasEntered(false);
      setAnimateIsVisible(false);
      var timeoutId = setTimeout(function () {
        setIsMounted(false);
      }, exitTransitionDuration);
      return function () {
        clearTimeout(timeoutId);
      };
    }
  }, [isVisible, exitTransitionDuration]);
  react.useEffect(function () {
    if (isVisible && isMounted && !animateIsVisible) {
      // Force a reflow so the initial styles are flushed to the DOM
      if (typeof document !== undefined) {
        // We need a side effect so Terser doesn't remove this statement
        window._usePresenceReflow = document.body.offsetHeight;
      }

      var animationFrameId = requestAnimationFrame(function () {
        setAnimateIsVisible(true);
      });
      return function () {
        cancelAnimationFrame(animationFrameId);
      };
    }
  }, [animateIsVisible, enterTransitionDuration, isMounted, isVisible]);
  react.useEffect(function () {
    if (animateIsVisible && !hasEntered) {
      var timeoutId = setTimeout(function () {
        setHasEntered(true);
      }, enterTransitionDuration);
      return function () {
        clearTimeout(timeoutId);
      };
    }
  }, [animateIsVisible, enterTransitionDuration, hasEntered]);
  return {
    isMounted: isMounted,
    isVisible: animateIsVisible,
    isAnimating: isAnimating,
    isEntering: isEntering,
    isExiting: isExiting
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function usePresenceSwitch(item, opts) {
  var _useState = react.useState(item),
      mountedItem = _useState[0],
      setMountedItem = _useState[1];

  var _useState2 = react.useState(item !== undefined),
      shouldBeMounted = _useState2[0],
      setShouldBeMounted = _useState2[1];

  var _usePresence = usePresence(shouldBeMounted, opts),
      isMounted = _usePresence.isMounted,
      rest = _objectWithoutPropertiesLoose(_usePresence, ["isMounted"]);

  react.useEffect(function () {
    if (mountedItem !== item) {
      if (isMounted) {
        setShouldBeMounted(false);
      } else if (item !== undefined) {
        setMountedItem(item);
        setShouldBeMounted(true);
      }
    } else if (item === undefined) {
      setShouldBeMounted(false);
    } else if (item !== undefined) {
      setShouldBeMounted(true);
    }
  }, [item, mountedItem, shouldBeMounted, isMounted]);
  return _extends({}, rest, {
    isMounted: isMounted && mountedItem !== undefined,
    mountedItem: mountedItem
  });
}

exports.default = usePresence;
exports.usePresenceSwitch = usePresenceSwitch;
//# sourceMappingURL=use-presence.cjs.development.js.map
